---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import fs from 'node:fs';
import path from 'node:path';

// Load season stats (pre-fetched by scripts/fetch-season-stats.cjs)
let seasonStatsData: Record<string, any> = {};
try {
  const seasonPath = path.join(process.cwd(), 'public/data/season-stats.json');
  seasonStatsData = JSON.parse(fs.readFileSync(seasonPath, 'utf8'));
} catch {
  // No season stats available yet
}

// Get all data for client-side comparison (filter out unpublished)
const allPlayers = await getCollection('players');
const players = allPlayers.filter(p => p.data.published !== false);
const mice = await getCollection('mice');
const mousepads = await getCollection('mousepads');
const keyboards = await getCollection('keyboards');
const monitors = await getCollection('monitors');
const headsets = await getCollection('headsets');

// Create lookup maps
const miceMap = Object.fromEntries(mice.map(m => [m.id, m.data]));
const mousepadsMap = Object.fromEntries(mousepads.map(m => [m.id, m.data]));
const keyboardsMap = Object.fromEntries(keyboards.map(k => [k.id, k.data]));
const monitorsMap = Object.fromEntries(monitors.map(m => [m.id, m.data]));
const headsetsMap = Object.fromEntries(headsets.map(h => [h.id, h.data]));

// Prepare player data for client
const playersData = Object.fromEntries(
  players.map(p => [p.id, {
    ...p.data,
    id: p.id,
    mouseData: miceMap[p.data.mouse] || null,
    mousepadData: mousepadsMap[p.data.mousepad] || null,
    keyboardData: keyboardsMap[p.data.keyboard] || null,
    monitorData: monitorsMap[p.data.monitor] || null,
    headsetData: headsetsMap[p.data.headset] || null,
  }])
);

const sortedPlayers = players.sort((a, b) => a.data.name.localeCompare(b.data.name));

const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;

const schema = {
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Quake Live Player Comparison Tool",
  "description": "Compare settings and hardware between Quake Live players",
  "url": "https://stripyq.github.io/quakesettings/compare/",
  "applicationCategory": "GameApplication"
};
---

<BaseLayout title="Compare Players" description="Compare settings and hardware between Quake Live players side-by-side. See sensitivity, keybinds, crosshairs, and gear differences." schema={schema} ogImage="/images/og/compare.jpg">
  <div class="page-header">
    <h1>Compare Players</h1>
    <p>Select two players to compare their settings side by side</p>
  </div>

  <div class="compare-selectors">
    <div class="selector-group">
      <label for="player1">Player 1</label>
      <select id="player1">
        <option value="">Select a player...</option>
        {sortedPlayers.map(p => (
          <option value={p.id}>{p.data.name}</option>
        ))}
      </select>
    </div>
    <div class="vs-badge">VS</div>
    <div class="selector-group">
      <label for="player2">Player 2</label>
      <select id="player2">
        <option value="">Select a player...</option>
        {sortedPlayers.map(p => (
          <option value={p.id}>{p.data.name}</option>
        ))}
      </select>
    </div>
  </div>

  <div id="comparison-container" class="comparison-container hidden">
    <table class="compare-table">
      <thead>
        <tr>
          <th class="label-header">Setting</th>
          <th id="p1-header" class="player-header">Player 1</th>
          <th id="p2-header" class="player-header">Player 2</th>
        </tr>
      </thead>
      <tbody id="compare-body">
        <!-- Populated by JavaScript -->
      </tbody>
    </table>
  </div>

  <div id="h2h-container" class="h2h-container hidden"></div>
  <div id="season-compare-container" class="season-compare-container hidden"></div>
  <div id="rivalries-container" class="rivalries-container hidden"></div>

  <div id="empty-state" class="empty-state">
    <p>Select two players above to compare their settings</p>
  </div>

  <script define:vars={{ playersData, base, seasonStatsData }}>
    document.addEventListener('DOMContentLoaded', function() {
      const player1Select = document.getElementById('player1');
      const player2Select = document.getElementById('player2');
      const comparisonContainer = document.getElementById('comparison-container');
      const emptyState = document.getElementById('empty-state');
      const compareBody = document.getElementById('compare-body');
      const p1Header = document.getElementById('p1-header');
      const p2Header = document.getElementById('p2-header');
      const h2hContainer = document.getElementById('h2h-container');
      const seasonCompareContainer = document.getElementById('season-compare-container');
      const rivalriesContainer = document.getElementById('rivalries-container');

      // Check URL params for pre-selected players
      const urlParams = new URLSearchParams(window.location.search);
      const p1Param = urlParams.get('p1');
      const p2Param = urlParams.get('p2');

      if (p1Param && playersData[p1Param]) {
        player1Select.value = p1Param;
      }
      if (p2Param && playersData[p2Param]) {
        player2Select.value = p2Param;
      }

      function formatValue(val, isNumeric = false, decimals = 0) {
        if (val === null || val === undefined || val === '' || val === 'Unknown') return '';
        if (isNumeric && typeof val === 'number') {
          return decimals > 0 ? val.toFixed(decimals) : val.toString();
        }
        return val;
      }

      function formatRating(num) {
        if (num === null || num === undefined) return '';
        // Remove trailing zeros after decimal (22.00 → 22, 22.50 → 22.5, 25.26 → 25.26)
        return parseFloat(Number(num).toFixed(2)).toString();
      }

      // cm/360 calculation - two modes:
      // 1. Standard (m_cpi = 0): cm/360 = (360 / (m_yaw × dpi × sens)) × 2.54
      // 2. With m_cpi > 0: cm/360 = (360 / sens) × (m_cpi / dpi)
      // Sources:
      //   https://funender.com/quake/mouse/index.html
      //   https://www.esreality.com/post/2256180/re-mouse-sensitivity/
      function formatCm360(player) {
        let val;
        if (player.dpi && player.sensitivity) {
          if (player.m_cpi && player.m_cpi > 0) {
            val = (360 / player.sensitivity) * (player.m_cpi / player.dpi);
          } else {
            const yaw = player.m_yaw || 0.022;
            val = (360 / (yaw * player.dpi * player.sensitivity)) * 2.54;
          }
        } else {
          val = player.cm360 || 0;
        }
        const fixed = val.toFixed(2);
        return fixed.endsWith('.00') ? Math.round(val).toString() : fixed;
      }

      // Real Accel calculation — normalizes acceleration across different DPI settings
      // Formula (style 0/legacy): ((dpi × windowsSens / 2.54)² × m_yaw × accelValue) / 1000
      // Source: https://funender.com/quake/mouse/index.html
      function calculateRealAccel(player) {
        if (!player.acceleration || !player.accelValue || player.accelValue <= 0) return null;
        if (!player.dpi) return null;
        if (player.accelStyle === 1) return null;
        const yaw = player.m_yaw || 0.022;
        const windowsSens = player.rawInput ? 1 : (player.windowsSensitivity || 1);
        const dpiTerm = (player.dpi * windowsSens) / 2.54;
        const realAccel = (Math.pow(dpiTerm, 2) * yaw * player.accelValue) / 1000;
        return Math.round(realAccel * 100) / 100;
      }

      function formatRealAccel(val) {
        if (val === null) return '';
        const fixed = val.toFixed(2);
        return fixed.endsWith('.00') ? Math.round(val).toString() : fixed;
      }

      function formatBind(val) {
        if (!val) return '';
        return String(val).toUpperCase();
      }

      function countryCodeToFlag(code) {
        if (!code || code.length !== 2) return '';
        return code
          .toUpperCase()
          .split('')
          .map(char => String.fromCodePoint(127397 + char.charCodeAt(0)))
          .join('');
      }

      function radarChartRow(p1, p2) {
        const hasAny = p1.accuracy_rg != null || p2.accuracy_rg != null ||
                        p1.accuracy_lg != null || p2.accuracy_lg != null ||
                        p1.accuracy_rl != null || p2.accuracy_rl != null;
        if (!hasAny) return '';

        // 6 axes: hexagon layout - weapons grouped, then other stats
        const axes = [
          { label: 'RG', angle: 90 },
          { label: 'LG', angle: 30 },
          { label: 'RL', angle: -30 },
          { label: 'cm/360\u00b0', angle: -90 },
          { label: 'Games', angle: -150 },
          { label: 'Rating', angle: 150 }
        ];
        const cx = 160, cy = 155, outerR = 100;

        function polarToCart(angleDeg, r) {
          const rad = angleDeg * Math.PI / 180;
          return { x: cx + r * Math.cos(rad), y: cy - r * Math.sin(rad) };
        }

        function getCm360Raw(player) {
          if (player.dpi && player.sensitivity) {
            if (player.m_cpi && player.m_cpi > 0) {
              return (360 / player.sensitivity) * (player.m_cpi / player.dpi);
            }
            const yaw = player.m_yaw || 0.022;
            return (360 / (yaw * player.dpi * player.sensitivity)) * 2.54;
          }
          return player.cm360 || null;
        }

        function getRating(player) {
          return player.ctfRating || player.tdmRating || null;
        }

        function getTotalGames(player) {
          const ctf = player.ctfGames || 0;
          const tdm = player.tdmGames || 0;
          return ctf + tdm;
        }

        function getPlayerValues(player) {
          const rg = player.accuracy_rg || 0;
          const lg = player.accuracy_lg || 0;
          const rl = player.accuracy_rl || 0;

          const cm360 = getCm360Raw(player);
          const cm360Norm = cm360 != null
            ? Math.max(0, Math.min(100, ((70 - cm360) / 60) * 100))
            : 50;

          const games = getTotalGames(player);
          const gamesNorm = Math.min(100, (games / 2000) * 100);

          const rating = getRating(player);
          const ratingNorm = rating != null
            ? Math.max(0, Math.min(100, ((rating - 15) / 35) * 100))
            : 50;

          return [rg, lg, rl, cm360Norm, gamesNorm, ratingNorm];
        }

        // Grid rings
        let gridSvg = '';
        [20, 40, 60, 80, 100].forEach(pct => {
          const r = (pct / 100) * outerR;
          const pts = axes.map(a => {
            const p = polarToCart(a.angle, r);
            return p.x + ',' + p.y;
          }).join(' ');
          gridSvg += '<polygon points="' + pts + '" fill="none" stroke="#374151" stroke-width="1"/>';
        });

        // Axis lines + labels
        let axesSvg = '';
        axes.forEach(a => {
          const outer = polarToCart(a.angle, outerR);
          axesSvg += '<line x1="' + cx + '" y1="' + cy + '" x2="' + outer.x + '" y2="' + outer.y + '" stroke="#374151" stroke-width="1"/>';
          const labelPos = polarToCart(a.angle, outerR + 18);
          axesSvg += '<text x="' + labelPos.x + '" y="' + labelPos.y + '" fill="#d1d5db" font-size="12" font-weight="600" text-anchor="middle" dominant-baseline="central">' + a.label + '</text>';
        });

        // Tick labels on the RG axis (top)
        let tickSvg = '';
        [20, 40, 60, 80, 100].forEach(pct => {
          const r = (pct / 100) * outerR;
          const p = polarToCart(90, r);
          tickSvg += '<text x="' + (p.x + 14) + '" y="' + p.y + '" fill="#6b7280" font-size="9" text-anchor="start" dominant-baseline="central">' + pct + '</text>';
        });

        // Player polygons (P2 uses dashed stroke for distinction)
        function playerPoly(player, color, dashed) {
          const values = getPlayerValues(player);
          const pts = values.map((val, i) => {
            const r = (val / 100) * outerR;
            const p = polarToCart(axes[i].angle, r);
            return p.x + ',' + p.y;
          }).join(' ');
          const dashAttr = dashed ? ' stroke-dasharray="6,3"' : '';
          return '<polygon points="' + pts + '" fill="' + color + '" fill-opacity="0.35" stroke="' + color + '" stroke-width="3"' + dashAttr + '/>';
        }

        // Player dots
        function playerDots(player, color) {
          const values = getPlayerValues(player);
          let dots = '';
          values.forEach((val, i) => {
            const r = (val / 100) * outerR;
            const p = polarToCart(axes[i].angle, r);
            dots += '<circle cx="' + p.x + '" cy="' + p.y + '" r="5" fill="' + color + '"/>';
          });
          return dots;
        }

        const p1Color = '#3b82f6';
        const p2Color = '#f97316';

        const svgContent = gridSvg + axesSvg + tickSvg +
          playerPoly(p1, p1Color, false) +
          playerPoly(p2, p2Color, true) +
          playerDots(p1, p1Color) +
          playerDots(p2, p2Color);

        // Chart row: legend above, then chart
        let html = '<tr class="data-row"><td colspan="3" class="radar-cell">' +
          '<div class="radar-chart-wrapper">' +
          '<div class="radar-legend">' +
          '<span class="radar-legend-item"><span class="radar-swatch" style="background:' + p1Color + '"></span>' + p1.name + '</span>' +
          '<span class="radar-legend-item"><span class="radar-swatch" style="background:' + p2Color + '"></span>' + p2.name + '</span>' +
          '</div>' +
          '<svg viewBox="0 0 320 310" width="320" height="310" xmlns="http://www.w3.org/2000/svg">' +
          svgContent + '</svg>' +
          '</div></td></tr>';

        // Accuracy value rows only (cm/360° and Rating already shown elsewhere)
        html += compareRow('RG', p1.accuracy_rg != null ? p1.accuracy_rg + '%' : '', p2.accuracy_rg != null ? p2.accuracy_rg + '%' : '', true);
        html += compareRow('LG', p1.accuracy_lg != null ? p1.accuracy_lg + '%' : '', p2.accuracy_lg != null ? p2.accuracy_lg + '%' : '', true);
        html += compareRow('RL', p1.accuracy_rl != null ? p1.accuracy_rl + '%' : '', p2.accuracy_rl != null ? p2.accuracy_rl + '%' : '', true);

        return html;
      }

      function updateComparison() {
        const p1Id = player1Select.value;
        const p2Id = player2Select.value;

        if (!p1Id || !p2Id) {
          comparisonContainer.classList.add('hidden');
          h2hContainer.classList.add('hidden');
          seasonCompareContainer.classList.add('hidden');
          rivalriesContainer.classList.add('hidden');
          emptyState.classList.remove('hidden');
          return;
        }

        const p1 = playersData[p1Id];
        const p2 = playersData[p2Id];

        if (!p1 || !p2) return;

        comparisonContainer.classList.remove('hidden');
        emptyState.classList.add('hidden');

        // Update URL
        const newUrl = `${window.location.pathname}?p1=${p1Id}&p2=${p2Id}`;
        window.history.replaceState({}, '', newUrl);

        // Update headers with flag emojis
        const p1Country = p1.country && p1.country !== 'Unknown' ? p1.country : '';
        const p2Country = p2.country && p2.country !== 'Unknown' ? p2.country : '';
        const p1Flag = countryCodeToFlag(p1Country);
        const p2Flag = countryCodeToFlag(p2Country);

        // Debug: log flag conversion (remove after debugging)
        console.log('Flag debug:', {
          p1: { country: p1.country, filtered: p1Country, flag: p1Flag, flagLength: p1Flag.length },
          p2: { country: p2.country, filtered: p2Country, flag: p2Flag, flagLength: p2Flag.length }
        });

        p1Header.innerHTML = `<span class="header-name">${p1.name}</span>${p1Flag ? `<span class="header-country">${p1Flag}</span>` : ''}`;
        p2Header.innerHTML = `<span class="header-name">${p2.name}</span>${p2Flag ? `<span class="header-country">${p2Flag}</span>` : ''}`;

        // Build comparison table
        let html = '';

        // Team row (show if at least one player has a team)
        if (p1.team2026 || p2.team2026) {
          html += compareRow('Team', p1.team2026 || '', p2.team2026 || '');
        }

        // Section: Mouse Settings
        html += sectionHeader('Mouse Settings');
        html += compareRow('cm/360', formatCm360(p1), formatCm360(p2), true);
        html += compareRow('Acceleration',
          p1.acceleration ? (p1.accelValue ? String(p1.accelValue) : 'On') : 'Off',
          p2.acceleration ? (p2.accelValue ? String(p2.accelValue) : 'On') : 'Off');

        // Show Real Accel row if either player uses accel
        const p1RealAccel = calculateRealAccel(p1);
        const p2RealAccel = calculateRealAccel(p2);
        if (p1RealAccel !== null || p2RealAccel !== null) {
          html += compareRow('Real Accel', formatRealAccel(p1RealAccel), formatRealAccel(p2RealAccel), true);
        }

        html += compareRow('eDPI', p1.edpi, p2.edpi, true);
        html += compareRow('Sensitivity', p1.sensitivity, p2.sensitivity, true);
        html += compareRow('DPI', p1.dpi, p2.dpi, true);
        html += compareRow('m_yaw', formatValue(p1.m_yaw), formatValue(p2.m_yaw));

        // Section: Mouse Hardware
        html += sectionHeader('Mouse Hardware');
        html += compareHardwareRow('Mouse', p1.mouseData, p2.mouseData);
        html += compareRow('Mouse Shape', formatValue(p1.mouseData?.shape), formatValue(p2.mouseData?.shape));
        html += compareRow('Grip Style', formatValue(p1.grip), formatValue(p2.grip));
        html += compareHardwareRow('Mousepad', p1.mousepadData, p2.mousepadData);
        html += compareRow('Skates', formatValue(p1.skates), formatValue(p2.skates));

        // Section: Game Settings
        html += sectionHeader('Game Settings');
        html += compareRow('FOV', p1.fov, p2.fov, true);
        html += compareRow('Crosshair', formatValue(p1.crosshair), formatValue(p2.crosshair));
        html += compareRow('Enemy Model', formatValue(p1.enemyModel), formatValue(p2.enemyModel));

        // Section: Key Bindings
        html += sectionHeader('Key Bindings');
        html += compareRow('Forward', formatBind(p1.forward), formatBind(p2.forward));
        html += compareRow('Back', formatBind(p1.back), formatBind(p2.back));
        html += compareRow('Left', formatBind(p1.left), formatBind(p2.left));
        html += compareRow('Right', formatBind(p1.right), formatBind(p2.right));
        html += compareRow('Jump', formatBind(p1.jump), formatBind(p2.jump));
        html += compareRow('Fire', formatBind(p1.attack), formatBind(p2.attack));
        html += compareRow('Zoom', formatBind(p1.zoom), formatBind(p2.zoom));
        html += compareRow('Crouch', formatBind(p1.crouch), formatBind(p2.crouch));

        // Section: Other Hardware
        html += sectionHeader('Other Hardware');
        html += compareHardwareRow('Keyboard', p1.keyboardData, p2.keyboardData);
        html += compareHardwareRow('Monitor', p1.monitorData, p2.monitorData);
        html += compareHardwareRow('Headset', p1.headsetData, p2.headsetData);

        // Section: Ratings (only show if at least one player has data)
        const hasRatings = p1.duelRating || p2.duelRating || p1.tdmRating || p2.tdmRating || p1.ctfRating || p2.ctfRating;
        if (hasRatings) {
          html += sectionHeader('Ratings');
          if (p1.duelRating || p2.duelRating) {
            html += compareRow('Duel', formatRating(p1.duelRating), formatRating(p2.duelRating), true);
          }
          if (p1.tdmRating || p2.tdmRating) {
            html += compareRow('TDM', formatRating(p1.tdmRating), formatRating(p2.tdmRating), true);
          }
          if (p1.ctfRating || p2.ctfRating) {
            html += compareRow('CTF', formatRating(p1.ctfRating), formatRating(p2.ctfRating), true);
          }
        }

        // Section: HoQ Stats (only show if at least one player has data)
        const hasHoq = p1.favorite_map || p2.favorite_map || p1.accuracy_rg || p2.accuracy_rg;
        if (hasHoq) {
          html += sectionHeader('HoQ Stats');
          html += compareRow('Favorite Map', p1.favorite_map || '\u2014', p2.favorite_map || '\u2014');
          html += compareRow('Favorite Gametype', p1.favorite_gametype || '\u2014', p2.favorite_gametype || '\u2014');
          html += compareRow('Favorite Weapon', p1.favorite_weapon || '\u2014', p2.favorite_weapon || '\u2014');
          html += radarChartRow(p1, p2);
        }

        compareBody.innerHTML = html;
        updateH2H(p1, p2);
        updateSeasonCompare(p1, p2);
        updateRivalries(p1, p2);
      }

      function updateH2H(p1, p2) {
        h2hContainer.classList.add('hidden');
        h2hContainer.innerHTML = '';

        if (!p1.steamId || !p2.steamId) return;

        // Look up pre-fetched head-to-head data from season stats
        const p1Stats = seasonStatsData[p1.steamId];
        const raw = p1Stats?.headToHead;
        if (!raw) return;

        // Data may be { data: [...] } or a plain array
        const data = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : null);
        if (!data) return;

        // Find p2 in the head-to-head list
        const match = data.find(function(entry) {
          return entry.steam_id === p2.steamId
            || entry.opponent_steam_id === p2.steamId;
        });

        if (!match) return;

        // Support both possible field name conventions
        const p1Kills = match.kills_against != null ? match.kills_against
          : (match.kills != null ? match.kills : match.wins);
        const p2Kills = match.deaths_to != null ? match.deaths_to
          : (match.deaths != null ? match.deaths : match.losses);

        if (p1Kills == null || p2Kills == null) return;

        const total = p1Kills + p2Kills;
        const p1Pct = total > 0 ? (p1Kills / total) * 100 : 50;
        const winRate = p1Pct.toFixed(1);
        const matchesTogether = match.matches_together || match.games || match.total_games || null;

        h2hContainer.innerHTML =
          '<div class="h2h-card">' +
            '<div class="h2h-title">Head to Head</div>' +
            '<div class="h2h-matchup">' +
              '<div class="h2h-side h2h-left">' +
                '<span class="h2h-name h2h-p1-color">' + p1.name + '</span>' +
                '<span class="h2h-kill-count h2h-p1-color">' + p1Kills + '</span>' +
              '</div>' +
              '<div class="h2h-vs">vs</div>' +
              '<div class="h2h-side h2h-right">' +
                '<span class="h2h-kill-count h2h-p2-color">' + p2Kills + '</span>' +
                '<span class="h2h-name h2h-p2-color">' + p2.name + '</span>' +
              '</div>' +
            '</div>' +
            '<div class="h2h-bar">' +
              '<div class="h2h-bar-p1" style="width:' + p1Pct + '%"></div>' +
              '<div class="h2h-bar-p2" style="width:' + (100 - p1Pct) + '%"></div>' +
            '</div>' +
            '<div class="h2h-meta">' +
              '<span class="h2h-winrate">' + winRate + '% kill rate for <span class="h2h-p1-color">' + p1.name + '</span></span>' +
              (matchesTogether ? '<span class="h2h-games">' + matchesTogether + ' games together</span>' : '') +
            '</div>' +
          '</div>';
        h2hContainer.classList.remove('hidden');
      }

      function updateSeasonCompare(p1, p2) {
        seasonCompareContainer.classList.add('hidden');
        seasonCompareContainer.innerHTML = '';

        if (!p1.steamId || !p2.steamId) return;

        const p1Stats = seasonStatsData[p1.steamId];
        const p2Stats = seasonStatsData[p2.steamId];
        if (!p1Stats && !p2Stats) return;

        const p1Career = p1Stats?.career;
        const p2Career = p2Stats?.career;
        const p1Flags = p1Stats?.flagStats?.data || p1Stats?.flagStats;
        const p2Flags = p2Stats?.flagStats?.data || p2Stats?.flagStats;

        // Need at least some career data
        if (!p1Career && !p2Career) return;

        function getVal(obj, keys) {
          if (!obj) return null;
          for (const k of keys) {
            if (obj[k] != null) return obj[k];
          }
          return null;
        }

        function calcWinRate(career) {
          if (!career) return null;
          const w = getVal(career, ['wins', 'total_wins']) || 0;
          const l = getVal(career, ['losses', 'total_losses']) || 0;
          const total = w + l;
          return total > 0 ? ((w / total) * 100).toFixed(1) : null;
        }

        function calcKD(career) {
          if (!career) return null;
          const k = getVal(career, ['kills', 'total_kills']) || 0;
          const d = getVal(career, ['deaths', 'total_deaths']) || 1;
          return d > 0 ? (k / d).toFixed(2) : null;
        }

        function calcDPM(career) {
          if (!career) return null;
          const dmg = getVal(career, ['damage_dealt', 'total_damage', 'damage']) || 0;
          const time = getVal(career, ['play_time', 'total_play_time', 'time_played']) || 0;
          if (time <= 0) return null;
          return Math.round(dmg / (time / 60));
        }

        // Build stat rows: [label, p1Value, p2Value, higherIsBetter]
        const rows = [];

        const p1Games = getVal(p1Career, ['games', 'total_games', 'matches']) || 0;
        const p2Games = getVal(p2Career, ['games', 'total_games', 'matches']) || 0;
        if (p1Games || p2Games) rows.push(['Games', p1Games || '\u2014', p2Games || '\u2014', true]);

        const p1WR = calcWinRate(p1Career);
        const p2WR = calcWinRate(p2Career);
        if (p1WR || p2WR) rows.push(['Win Rate', p1WR ? p1WR + '%' : '\u2014', p2WR ? p2WR + '%' : '\u2014', true]);

        const p1KD = calcKD(p1Career);
        const p2KD = calcKD(p2Career);
        if (p1KD || p2KD) rows.push(['K/D', p1KD || '\u2014', p2KD || '\u2014', true]);

        const p1DPM = calcDPM(p1Career);
        const p2DPM = calcDPM(p2Career);
        if (p1DPM || p2DPM) rows.push(['DPM', p1DPM || '\u2014', p2DPM || '\u2014', true]);

        const p1Kills = getVal(p1Career, ['kills', 'total_kills']) || 0;
        const p2Kills = getVal(p2Career, ['kills', 'total_kills']) || 0;
        if (p1Kills || p2Kills) rows.push(['Kills', p1Kills || '\u2014', p2Kills || '\u2014', true]);

        const p1Streak = getVal(p1Career, ['best_streak', 'best_killstreak', 'kill_streak']) || 0;
        const p2Streak = getVal(p2Career, ['best_streak', 'best_killstreak', 'kill_streak']) || 0;
        if (p1Streak || p2Streak) rows.push(['Best Streak', p1Streak || '\u2014', p2Streak || '\u2014', true]);

        // Flag stats
        const p1Caps = getVal(p1Flags, ['captures', 'flag_captures', 'total_captures']) || 0;
        const p2Caps = getVal(p2Flags, ['captures', 'flag_captures', 'total_captures']) || 0;
        const p1Rets = getVal(p1Flags, ['returns', 'flag_returns', 'total_returns']) || 0;
        const p2Rets = getVal(p2Flags, ['returns', 'flag_returns', 'total_returns']) || 0;

        const hasFlags = p1Caps || p2Caps || p1Rets || p2Rets;

        if (rows.length === 0 && !hasFlags) return;

        function statRow(label, v1, v2, higherBetter) {
          const n1 = parseFloat(v1);
          const n2 = parseFloat(v2);
          let p1Class = '';
          let p2Class = '';
          if (!isNaN(n1) && !isNaN(n2) && n1 !== n2) {
            if (higherBetter) {
              p1Class = n1 > n2 ? 'stat-better' : 'stat-worse';
              p2Class = n2 > n1 ? 'stat-better' : 'stat-worse';
            } else {
              p1Class = n1 < n2 ? 'stat-better' : 'stat-worse';
              p2Class = n2 < n1 ? 'stat-better' : 'stat-worse';
            }
          }
          return '<tr>' +
            '<td class="sc-val ' + p1Class + '">' + v1 + '</td>' +
            '<td class="sc-label">' + label + '</td>' +
            '<td class="sc-val ' + p2Class + '">' + v2 + '</td>' +
          '</tr>';
        }

        let tableRows = '';
        for (const [label, v1, v2, hb] of rows) {
          tableRows += statRow(label, v1, v2, hb);
        }

        let flagRows = '';
        if (hasFlags) {
          if (p1Caps || p2Caps) flagRows += statRow('Captures', p1Caps || '\u2014', p2Caps || '\u2014', true);
          if (p1Rets || p2Rets) flagRows += statRow('Returns', p1Rets || '\u2014', p2Rets || '\u2014', true);
        }

        seasonCompareContainer.innerHTML =
          '<div class="sc-card">' +
            '<div class="sc-title">Season Stats</div>' +
            '<table class="sc-table">' +
              '<thead><tr>' +
                '<th class="sc-th-player h2h-p1-color">' + p1.name + '</th>' +
                '<th class="sc-th-label"></th>' +
                '<th class="sc-th-player h2h-p2-color">' + p2.name + '</th>' +
              '</tr></thead>' +
              '<tbody>' + tableRows + '</tbody>' +
              (flagRows ? '<tbody class="sc-flag-section"><tr><td colspan="3" class="sc-section-label">Flag Stats</td></tr>' + flagRows + '</tbody>' : '') +
            '</table>' +
          '</div>';
        seasonCompareContainer.classList.remove('hidden');
      }

      function updateRivalries(p1, p2) {
        rivalriesContainer.classList.add('hidden');
        rivalriesContainer.innerHTML = '';

        if (!p1.steamId || !p2.steamId) return;

        const p1Stats = seasonStatsData[p1.steamId];
        const p2Stats = seasonStatsData[p2.steamId];

        const p1Nem = p1Stats?.nemesis?.data || p1Stats?.nemesis;
        const p2Nem = p2Stats?.nemesis?.data || p2Stats?.nemesis;
        const p1Vic = p1Stats?.favoriteVictim?.data || p1Stats?.favoriteVictim;
        const p2Vic = p2Stats?.favoriteVictim?.data || p2Stats?.favoriteVictim;

        if (!p1Nem && !p2Nem && !p1Vic && !p2Vic) return;

        function rivalryEntry(label, data) {
          if (!data) return '<div class="rv-entry"><span class="rv-type">' + label + '</span><span class="rv-unknown">\u2014</span></div>';
          const name = data.name || data.opponent_name || '???';
          const kd = data.kd_ratio != null ? parseFloat(data.kd_ratio).toFixed(2) : null;
          return '<div class="rv-entry">' +
            '<span class="rv-type">' + label + '</span>' +
            '<span class="rv-name">' + name + '</span>' +
            (kd ? '<span class="rv-kd">' + kd + ' K/D</span>' : '') +
          '</div>';
        }

        rivalriesContainer.innerHTML =
          '<div class="rv-card">' +
            '<div class="rv-title">Rivalries</div>' +
            '<div class="rv-columns">' +
              '<div class="rv-col rv-col-left">' +
                '<div class="rv-player-name h2h-p1-color">' + p1.name + '</div>' +
                rivalryEntry('Nemesis', p1Nem) +
                rivalryEntry('Favorite Victim', p1Vic) +
              '</div>' +
              '<div class="rv-divider"></div>' +
              '<div class="rv-col rv-col-right">' +
                '<div class="rv-player-name h2h-p2-color">' + p2.name + '</div>' +
                rivalryEntry('Nemesis', p2Nem) +
                rivalryEntry('Favorite Victim', p2Vic) +
              '</div>' +
            '</div>' +
          '</div>';
        rivalriesContainer.classList.remove('hidden');
      }

      function sectionHeader(title) {
        return `<tr class="section-row"><td colspan="3">${title}</td></tr>`;
      }

      function compareRow(label, val1, val2, isNumeric = false) {
        const v1 = val1 !== undefined && val1 !== null ? String(val1) : '';
        const v2 = val2 !== undefined && val2 !== null ? String(val2) : '';
        const isSame = v1 !== '' && v2 !== '' && v1 === v2;
        const isDiff = v1 !== '' && v2 !== '' && v1 !== v2;
        const highlightClass = isSame ? 'same-highlight' : '';
        const numClass = isNumeric ? 'numeric' : '';

        // Only show arrow on Player 2 column (right side)
        let diffIndicator2 = '';
        if (isDiff && isNumeric && v1 && v2) {
          const n1 = parseFloat(v1);
          const n2 = parseFloat(v2);
          if (!isNaN(n1) && !isNaN(n2)) {
            diffIndicator2 = n2 > n1
              ? '<span class="diff-arrow higher">▲</span>'
              : '<span class="diff-arrow lower">▼</span>';
          }
        }

        return `<tr class="data-row">
          <td class="label-cell">${label}</td>
          <td class="value-cell ${highlightClass} ${numClass}">${v1}</td>
          <td class="value-cell ${highlightClass} ${numClass}">${v2}${diffIndicator2}</td>
        </tr>`;
      }

      function compareHardwareRow(label, hw1, hw2) {
        const name1 = hw1?.name || '';
        const name2 = hw2?.name || '';
        const isSame = name1 !== '' && name2 !== '' && name1 === name2;
        const highlightClass = isSame ? 'same-highlight' : '';

        return `<tr class="data-row">
          <td class="label-cell">${label}</td>
          <td class="value-cell ${highlightClass}">${name1}</td>
          <td class="value-cell ${highlightClass}">${name2}</td>
        </tr>`;
      }

      player1Select.addEventListener('change', updateComparison);
      player2Select.addEventListener('change', updateComparison);

      // Initial update if params provided
      if (p1Param || p2Param) {
        updateComparison();
      }
    });
  </script>
</BaseLayout>

<style>
  .compare-selectors {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 2rem;
    margin: 2rem 0;
    flex-wrap: wrap;
  }

  .selector-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .selector-group label {
    color: var(--text-secondary, #9090a0);
    font-size: 0.875rem;
  }

  .selector-group select {
    background: var(--bg-card, #1a1a24);
    border: 1px solid var(--border-color, #2a2a35);
    color: var(--text-primary, #e8e8f0);
    padding: 0.75rem 1rem;
    border-radius: 6px;
    min-width: 200px;
    font-size: 1rem;
  }

  .vs-badge {
    background: var(--accent-primary, #ff6b35);
    color: white;
    font-weight: 700;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    font-size: 0.875rem;
  }

  .comparison-container {
    margin-top: 2rem;
    display: flex;
    justify-content: center;
  }

  .comparison-container.hidden {
    display: none;
  }

  .compare-table {
    max-width: 800px;
  }

  .empty-state {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--text-secondary, #9090a0);
  }

  .empty-state.hidden {
    display: none;
  }

  .compare-table {
    width: 100%;
    border-collapse: collapse;
    background: var(--bg-card, #1a1a24);
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid var(--border-color, #2a2a35);
  }

  .compare-table thead {
    background: var(--bg-secondary, #12121a);
  }

  .compare-table th {
    padding: 1rem;
    text-align: center;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .player-header {
    width: 30%;
  }

  .label-header {
    width: 40%;
    color: var(--text-secondary, #9090a0);
    font-size: 0.875rem;
    text-align: left;
  }

  .player-header :global(.header-name) {
    display: block;
    font-size: 1.25rem;
    color: var(--accent-secondary, #4ecdc4);
    font-weight: 600;
  }

  .player-header :global(.header-country) {
    display: block;
    font-size: 1.25rem;
    margin-top: 0.25rem;
  }

  /* Dynamic content styles need :global() */
  .compare-table :global(.section-row td) {
    padding: 0.75rem 1rem;
    background: rgba(249, 115, 22, 0.15);
    color: #f97316;
    font-size: 0.85rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    text-align: left;
    border-bottom: none;
    border-left: 4px solid #f97316;
  }

  .compare-table :global(.section-row:not(:first-child) td) {
    padding-top: 1.5rem;
    border-top: 1px solid var(--border-color, #2a2a35);
  }

  .compare-table :global(.data-row td) {
    padding: 0.6rem 1rem;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .compare-table :global(.data-row:last-child td) {
    border-bottom: none;
  }

  .compare-table :global(.label-cell) {
    text-align: left;
    color: var(--text-secondary, #9090a0);
    font-size: 0.85rem;
  }

  .compare-table :global(.value-cell) {
    font-size: 0.9rem;
  }

  /* Player 1 (2nd column) - right aligned */
  .compare-table :global(.value-cell:nth-child(2)) {
    text-align: right;
    padding-right: 1.5rem;
  }

  /* Player 2 (3rd column) - left aligned */
  .compare-table :global(.value-cell:nth-child(3)) {
    text-align: left;
    padding-left: 1.5rem;
  }

  .compare-table :global(.value-cell.same-highlight) {
    background: rgba(255, 107, 53, 0.1);
    color: var(--accent-primary, #ff6b35);
    font-weight: 500;
  }

  .compare-table :global(.value-cell.numeric) {
    font-family: monospace;
  }

  .compare-table :global(.diff-arrow) {
    font-size: 0.7rem;
    margin-left: 0.35rem;
  }

  .compare-table :global(.diff-arrow.higher) {
    color: #27ae60;
  }

  .compare-table :global(.diff-arrow.lower) {
    color: #e74c3c;
  }

  .hw-link {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: none;
    transition: color 0.2s;
  }

  .hw-link:hover {
    color: var(--accent-primary, #ff6b35);
    text-decoration: underline;
  }

  @media (max-width: 768px) {
    .compare-selectors {
      flex-direction: column;
      gap: 1rem;
    }

    .vs-badge {
      order: 2;
    }

    .selector-group:first-child {
      order: 1;
    }

    .selector-group:last-child {
      order: 3;
    }

    .compare-table {
      font-size: 0.85rem;
    }

    .compare-table th,
    .compare-table td {
      padding: 0.5rem;
    }

    .player-header :global(.header-name) {
      font-size: 1rem;
    }
  }

  .compare-table :global(.radar-cell) {
    padding: 0 !important;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .compare-table :global(.radar-chart-wrapper) {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1.25rem 1rem;
    background: rgba(18, 18, 26, 0.5);
  }

  .compare-table :global(.radar-legend) {
    display: flex;
    gap: 1.5rem;
    margin-bottom: 0.25rem;
    font-size: 0.8rem;
    color: #d1d5db;
  }

  .compare-table :global(.radar-legend-item) {
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }

  .compare-table :global(.radar-swatch) {
    display: inline-block;
    width: 10px;
    height: 10px;
    border-radius: 2px;
  }

  /* --- Head to Head --- */
  /* Dynamic content injected via innerHTML needs :global() for Astro scoping */

  .h2h-container {
    display: flex;
    justify-content: center;
    margin-top: 1.5rem;
  }

  .h2h-container.hidden {
    display: none;
  }

  .h2h-container :global(.h2h-card) {
    background: var(--bg-card, #1a1a24);
    border: 1px solid var(--border-color, #2a2a35);
    border-radius: 8px;
    padding: 1.5rem 2rem;
    text-align: center;
    max-width: 600px;
    width: 100%;
  }

  .h2h-container :global(.h2h-title) {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--accent-primary, #ff6b35);
    font-weight: 700;
    margin-bottom: 1.25rem;
  }

  .h2h-container :global(.h2h-matchup) {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .h2h-container :global(.h2h-side) {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex: 1;
  }

  .h2h-container :global(.h2h-left) {
    justify-content: flex-end;
  }

  .h2h-container :global(.h2h-right) {
    justify-content: flex-start;
  }

  .h2h-container :global(.h2h-name) {
    font-size: 0.95rem;
    font-weight: 600;
  }

  .h2h-container :global(.h2h-kill-count) {
    font-size: 1.75rem;
    font-weight: 800;
    font-family: monospace;
    line-height: 1;
  }

  .h2h-container :global(.h2h-vs) {
    color: var(--text-secondary, #9090a0);
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    flex-shrink: 0;
  }

  /* Shared color classes used across h2h, season-compare, and rivalries */
  :global(.h2h-p1-color) { color: #3b82f6; }
  :global(.h2h-p2-color) { color: #f97316; }

  .h2h-container :global(.h2h-bar) {
    display: flex;
    height: 8px;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.75rem;
  }

  .h2h-container :global(.h2h-bar-p1) {
    height: 100%;
    background: #3b82f6;
    border-radius: 4px 0 0 4px;
    transition: width 0.3s ease;
  }

  .h2h-container :global(.h2h-bar-p2) {
    height: 100%;
    background: #f97316;
    border-radius: 0 4px 4px 0;
    transition: width 0.3s ease;
  }

  .h2h-container :global(.h2h-meta) {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .h2h-container :global(.h2h-winrate) {
    font-size: 0.8rem;
    color: var(--text-secondary, #9090a0);
  }

  .h2h-container :global(.h2h-games) {
    font-size: 0.8rem;
    color: var(--text-secondary, #9090a0);
  }

  /* --- Season Stats Comparison --- */

  .season-compare-container {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
  }

  .season-compare-container.hidden {
    display: none;
  }

  .season-compare-container :global(.sc-card) {
    background: var(--bg-card, #1a1a24);
    border: 1px solid var(--border-color, #2a2a35);
    border-radius: 8px;
    padding: 1.5rem 2rem;
    max-width: 600px;
    width: 100%;
  }

  .season-compare-container :global(.sc-title) {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--accent-primary, #ff6b35);
    font-weight: 700;
    margin-bottom: 1rem;
    text-align: center;
  }

  .season-compare-container :global(.sc-table) {
    width: 100%;
    border-collapse: collapse;
  }

  .season-compare-container :global(.sc-th-player) {
    font-size: 0.85rem;
    font-weight: 700;
    padding: 0 0 0.75rem;
    width: 38%;
  }

  .season-compare-container :global(.sc-th-player:first-child) {
    text-align: right;
    padding-right: 1rem;
  }

  .season-compare-container :global(.sc-th-player:last-child) {
    text-align: left;
    padding-left: 1rem;
  }

  .season-compare-container :global(.sc-th-label) {
    width: 24%;
    padding: 0 0 0.75rem;
  }

  .season-compare-container :global(.sc-table tbody tr) {
    border-top: 1px solid var(--border-color, #2a2a35);
  }

  .season-compare-container :global(.sc-label) {
    text-align: center;
    color: var(--text-secondary, #9090a0);
    font-size: 0.8rem;
    padding: 0.5rem 0.5rem;
    white-space: nowrap;
  }

  .season-compare-container :global(.sc-val) {
    font-family: monospace;
    font-size: 0.9rem;
    padding: 0.5rem 1rem;
    color: var(--text-primary, #e8e8f0);
  }

  .season-compare-container :global(.sc-val:first-child) {
    text-align: right;
  }

  .season-compare-container :global(.sc-val:last-child) {
    text-align: left;
  }

  .season-compare-container :global(.sc-val.stat-better) {
    color: #34d399;
    font-weight: 600;
  }

  .season-compare-container :global(.sc-val.stat-worse) {
    color: var(--text-secondary, #9090a0);
  }

  .season-compare-container :global(.sc-section-label) {
    text-align: center;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-secondary, #9090a0);
    padding: 0.75rem 0 0.25rem;
    border-top: 1px solid var(--border-color, #2a2a35);
  }

  .season-compare-container :global(.sc-flag-section tr:first-child) {
    border-top: none;
  }

  /* --- Rivalries --- */

  .rivalries-container {
    display: flex;
    justify-content: center;
    margin-top: 1rem;
  }

  .rivalries-container.hidden {
    display: none;
  }

  .rivalries-container :global(.rv-card) {
    background: var(--bg-card, #1a1a24);
    border: 1px solid var(--border-color, #2a2a35);
    border-radius: 8px;
    padding: 1.5rem 2rem;
    max-width: 600px;
    width: 100%;
  }

  .rivalries-container :global(.rv-title) {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--accent-primary, #ff6b35);
    font-weight: 700;
    margin-bottom: 1.25rem;
    text-align: center;
  }

  .rivalries-container :global(.rv-columns) {
    display: flex;
    gap: 1.5rem;
    align-items: flex-start;
  }

  .rivalries-container :global(.rv-col) {
    flex: 1;
  }

  .rivalries-container :global(.rv-col-left) {
    text-align: right;
  }

  .rivalries-container :global(.rv-col-right) {
    text-align: left;
  }

  .rivalries-container :global(.rv-divider) {
    width: 1px;
    background: var(--border-color, #2a2a35);
    align-self: stretch;
    flex-shrink: 0;
  }

  .rivalries-container :global(.rv-player-name) {
    font-size: 0.9rem;
    font-weight: 700;
    margin-bottom: 0.75rem;
  }

  .rivalries-container :global(.rv-entry) {
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
    margin-bottom: 0.75rem;
  }

  .rivalries-container :global(.rv-col-left .rv-entry) {
    align-items: flex-end;
  }

  .rivalries-container :global(.rv-col-right .rv-entry) {
    align-items: flex-start;
  }

  .rivalries-container :global(.rv-type) {
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: var(--text-secondary, #9090a0);
  }

  .rivalries-container :global(.rv-name) {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-primary, #e8e8f0);
  }

  .rivalries-container :global(.rv-kd) {
    font-size: 0.75rem;
    font-family: monospace;
    color: var(--text-secondary, #9090a0);
  }

  .rivalries-container :global(.rv-unknown) {
    font-size: 0.85rem;
    color: var(--text-secondary, #9090a0);
  }

  /* --- Mobile responsive for new sections --- */

  @media (max-width: 768px) {
    .h2h-container :global(.h2h-card),
    .season-compare-container :global(.sc-card),
    .rivalries-container :global(.rv-card) {
      padding: 1rem 1rem;
    }

    .h2h-container :global(.h2h-matchup) {
      gap: 0.5rem;
    }

    .h2h-container :global(.h2h-name) {
      font-size: 0.8rem;
    }

    .h2h-container :global(.h2h-kill-count) {
      font-size: 1.25rem;
    }

    .h2h-container :global(.h2h-meta) {
      flex-direction: column;
      align-items: center;
    }

    .rivalries-container :global(.rv-columns) {
      gap: 0.75rem;
    }

    .season-compare-container :global(.sc-val) {
      font-size: 0.8rem;
      padding: 0.4rem 0.5rem;
    }

    .season-compare-container :global(.sc-label) {
      font-size: 0.7rem;
    }
  }

</style>
