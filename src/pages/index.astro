---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';

// Get all players and hardware
const players = await getCollection('players');
const mice = await getCollection('mice');
const keyboards = await getCollection('keyboards');
const headsets = await getCollection('headsets');
const monitors = await getCollection('monitors');

// Create lookup maps for hardware
const miceMap = new Map(mice.map(m => [m.id, m.data]));
const keyboardsMap = new Map(keyboards.map(k => [k.id, k.data]));
const headsetsMap = new Map(headsets.map(h => [h.id, h.data]));
const monitorsMap = new Map(monitors.map(m => [m.id, m.data]));

// Calculate cm/360 based on m_cpi setting
function calculateCm360(player: any): number {
  if (player.cm360) return player.cm360;
  if (player.m_cpi) {
    // If m_cpi is set: cm360 = 360 / sensitivity
    return Math.round((360 / player.sensitivity) * 100) / 100;
  }
  // Standard calculation: cm360 = 41563.6 / (DPI × sensitivity)
  return Math.round((41563.6 / (player.dpi * player.sensitivity)) * 100) / 100;
}

// Get team rating (higher of CTF or TDM)
function getTeamRating(player: any): { rating: number | null; type: 'ctf' | 'tdm' | null } {
  const ctf = player.ctfRating;
  const tdm = player.tdmRating;
  if (!ctf && !tdm) return { rating: null, type: null };
  if (!ctf) return { rating: tdm, type: 'tdm' };
  if (!tdm) return { rating: ctf, type: 'ctf' };
  return ctf >= tdm ? { rating: ctf, type: 'ctf' } : { rating: tdm, type: 'tdm' };
}

// Format rating for display
function formatRating(rating: number | null, isDuel: boolean): string {
  if (rating === null) return '—';
  return isDuel ? Math.round(rating).toString() : rating.toFixed(1);
}

// Sort players by name
const sortedPlayers = players.sort((a, b) => a.data.name.localeCompare(b.data.name));

// Ensure base URL has trailing slash for path concatenation
const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;
---

<BaseLayout title="Player Database">
  <div class="page-header">
    <h1>Quake Live Pro Settings</h1>
    <p>Mouse settings, hardware, and configs from {players.length} players</p>
  </div>

  <div class="filters">
    <div class="filter-group">
      <label for="category-filter">Category:</label>
      <select id="category-filter">
        <option value="all">All Players</option>
        <option value="duel">Duel</option>
        <option value="ctf">CTF</option>
        <option value="tdm">TDM</option>
      </select>
    </div>

    <div class="filter-group">
      <input type="text" id="player-search" placeholder="Search players or hardware..." class="search-input">
    </div>
  </div>

  <div class="table-container">
    <table class="player-table" id="player-table">
      <thead>
        <tr>
          <th class="sortable" data-sort="name">Player</th>
          <th class="sortable" data-sort="duel" title="Duel rating (Glicko from QLStats)">Duel</th>
          <th class="sortable" data-sort="team" title="Team rating (higher of CTF/TDM)">Team</th>
          <th class="sortable" data-sort="mouse">Mouse</th>
          <th class="sortable" data-sort="dpi">DPI</th>
          <th class="sortable" data-sort="sens">Sens</th>
          <th class="sortable" data-sort="cm360" title="cm/360° - distance to complete one full turn">cm/360</th>
          <th class="sortable" data-sort="accel">Accel</th>
          <th class="sortable" data-sort="fov">FOV</th>
          <th>Monitor</th>
          <th>Keyboard</th>
          <th>Headset</th>
          <th class="sortable" data-sort="updated">Updated</th>
        </tr>
      </thead>
      <tbody id="player-tbody">
        {sortedPlayers.map((player) => {
          const mouseData = miceMap.get(player.data.mouse);
          const keyboardData = keyboardsMap.get(player.data.keyboard);
          const headsetData = headsetsMap.get(player.data.headset);
          const monitorData = monitorsMap.get(player.data.monitor);
          const cm360 = calculateCm360(player.data);
          const hasAccel = player.data.acceleration;
          const teamInfo = getTeamRating(player.data);
          return (
            <tr
              class="player-row"
              data-name={player.data.name.toLowerCase()}
              data-category={player.data.category}
              data-dpi={player.data.dpi}
              data-sens={player.data.sensitivity}
              data-cm360={cm360}
              data-fov={player.data.fov}
              data-accel={hasAccel ? "1" : "0"}
              data-duel={player.data.duelRating || 0}
              data-team={teamInfo.rating || 0}
              data-mouse={mouseData?.name?.toLowerCase() || player.data.mouse?.toLowerCase() || ''}
              data-monitor={monitorData?.name?.toLowerCase() || player.data.monitor?.toLowerCase() || ''}
              data-keyboard={keyboardData?.name?.toLowerCase() || player.data.keyboard?.toLowerCase() || ''}
              data-headset={headsetData?.name?.toLowerCase() || player.data.headset?.toLowerCase() || ''}
              data-updated={player.data.lastUpdated || ''}
            >
              <td>
                <a href={`${base}players/${player.id}/`} class="player-link">
                  {player.data.name}
                </a>
              </td>
              <td class="rating-cell duel">{formatRating(player.data.duelRating || null, true)}</td>
              <td class="rating-cell team" title={teamInfo.type ? teamInfo.type.toUpperCase() : ''}>
                {formatRating(teamInfo.rating, false)}
                {teamInfo.type && <span class="rating-type">{teamInfo.type.toUpperCase()}</span>}
              </td>
              <td class="hw-cell">
                {mouseData?.affiliateLink ? (
                  <a href={mouseData.affiliateLink} target="_blank" rel="noopener" class="hw-link">{mouseData.name}</a>
                ) : (mouseData?.name || player.data.mouse || '—')}
              </td>
              <td class="num">{player.data.dpi}</td>
              <td class="num">{player.data.sensitivity}</td>
              <td class="num">{cm360.toFixed(2)}</td>
              <td class="accel-cell">{hasAccel ? 'Yes' : 'No'}</td>
              <td class="num">{player.data.fov}</td>
              <td class="hw-cell">
                {monitorData?.affiliateLink ? (
                  <a href={monitorData.affiliateLink} target="_blank" rel="noopener" class="hw-link">{monitorData.name}</a>
                ) : (monitorData?.name || player.data.monitor || '—')}
              </td>
              <td class="hw-cell">
                {keyboardData?.affiliateLink ? (
                  <a href={keyboardData.affiliateLink} target="_blank" rel="noopener" class="hw-link">{keyboardData.name}</a>
                ) : (keyboardData?.name || player.data.keyboard || '—')}
              </td>
              <td class="hw-cell">
                {headsetData?.affiliateLink ? (
                  <a href={headsetData.affiliateLink} target="_blank" rel="noopener" class="hw-link">{headsetData.name}</a>
                ) : (headsetData?.name || player.data.headset || '—')}
              </td>
              <td class="date-cell">{player.data.lastUpdated || '—'}</td>
            </tr>
          );
        })}
      </tbody>
    </table>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const searchInput = document.getElementById('player-search') as HTMLInputElement;
      const categoryFilter = document.getElementById('category-filter') as HTMLSelectElement;
      const tbody = document.getElementById('player-tbody');
      const headers = document.querySelectorAll('th.sortable');

      let sortCol = 'name';
      let sortAsc = true;

      function filterAndSort() {
        const search = searchInput?.value.toLowerCase() || '';
        const category = categoryFilter?.value || 'all';

        const rows = Array.from(tbody?.querySelectorAll('tr') || []) as HTMLTableRowElement[];

        rows.forEach(row => {
          const name = row.dataset.name || '';
          const mouse = row.dataset.mouse || '';
          const monitor = row.dataset.monitor || '';
          const keyboard = row.dataset.keyboard || '';
          const headset = row.dataset.headset || '';
          const cat = row.dataset.category || '';

          let show = true;

          // Search filter (searches player name and hardware)
          if (search && !name.includes(search) && !mouse.includes(search) && !monitor.includes(search) && !keyboard.includes(search) && !headset.includes(search)) {
            show = false;
          }

          // Category filter
          if (category !== 'all' && cat !== category) {
            show = false;
          }

          row.style.display = show ? '' : 'none';
        });

        // Sort visible rows
        const visibleRows = rows.filter(r => r.style.display !== 'none');
        visibleRows.sort((a, b) => {
          let aVal: string | number, bVal: string | number;
          switch(sortCol) {
            case 'name':
              aVal = a.dataset.name || '';
              bVal = b.dataset.name || '';
              break;
            case 'duel':
              aVal = parseFloat(a.dataset.duel || '0') || 0;
              bVal = parseFloat(b.dataset.duel || '0') || 0;
              break;
            case 'team':
              aVal = parseFloat(a.dataset.team || '0') || 0;
              bVal = parseFloat(b.dataset.team || '0') || 0;
              break;
            case 'mouse':
              aVal = a.dataset.mouse || '';
              bVal = b.dataset.mouse || '';
              break;
            case 'dpi':
              aVal = parseInt(a.dataset.dpi || '0') || 0;
              bVal = parseInt(b.dataset.dpi || '0') || 0;
              break;
            case 'sens':
              aVal = parseFloat(a.dataset.sens || '0') || 0;
              bVal = parseFloat(b.dataset.sens || '0') || 0;
              break;
            case 'cm360':
              aVal = parseFloat(a.dataset.cm360 || '0') || 0;
              bVal = parseFloat(b.dataset.cm360 || '0') || 0;
              break;
            case 'fov':
              aVal = parseInt(a.dataset.fov || '0') || 0;
              bVal = parseInt(b.dataset.fov || '0') || 0;
              break;
            case 'accel':
              aVal = a.dataset.accel || '0';
              bVal = b.dataset.accel || '0';
              break;
            case 'updated':
              aVal = a.dataset.updated || '';
              bVal = b.dataset.updated || '';
              break;
            default:
              aVal = a.dataset.name || '';
              bVal = b.dataset.name || '';
          }

          if (typeof aVal === 'string') {
            return sortAsc ? aVal.localeCompare(bVal as string) : (bVal as string).localeCompare(aVal);
          }
          return sortAsc ? (aVal as number) - (bVal as number) : (bVal as number) - (aVal as number);
        });

        visibleRows.forEach(row => tbody?.appendChild(row));
      }

      // Event listeners
      searchInput?.addEventListener('input', filterAndSort);
      categoryFilter?.addEventListener('change', filterAndSort);

      headers.forEach(header => {
        header.addEventListener('click', () => {
          const col = (header as HTMLElement).dataset.sort || 'name';
          if (sortCol === col) {
            sortAsc = !sortAsc;
          } else {
            sortCol = col;
            sortAsc = true;
          }

          // Update header styles
          headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
          header.classList.add(sortAsc ? 'sort-asc' : 'sort-desc');

          filterAndSort();
        });
      });
    });
  </script>
</BaseLayout>

<style>
  .table-container {
    overflow-x: auto;
    margin-top: 1.5rem;
    -webkit-overflow-scrolling: touch;
  }

  .player-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
  }

  .player-table th,
  .player-table td {
    padding: 0.6rem 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--border-color, #2a2a3a);
  }

  .player-table th {
    background: var(--bg-secondary, #12121a);
    font-weight: 600;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    white-space: nowrap;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .player-table th.sortable {
    cursor: pointer;
    user-select: none;
  }

  .player-table th.sortable:hover {
    color: var(--accent-primary, #ff6b35);
  }

  .player-table th.sortable::after {
    content: ' ↕';
    opacity: 0.3;
  }

  .player-table th.sort-asc::after {
    content: ' ↑';
    opacity: 1;
  }

  .player-table th.sort-desc::after {
    content: ' ↓';
    opacity: 1;
  }

  .header-info {
    font-size: 0.65rem;
    opacity: 0.6;
    cursor: help;
    margin-left: 0.25rem;
  }

  /* Zebra striping */
  .player-table tbody tr:nth-child(odd) {
    background: rgba(255, 255, 255, 0.02);
  }

  .player-table tbody tr:nth-child(even) {
    background: transparent;
  }

  .player-table tbody tr:hover {
    background: var(--bg-secondary, #12121a);
  }

  .player-link {
    color: var(--accent-primary, #ff6b35);
    text-decoration: none;
    font-weight: 500;
  }

  .player-link:hover {
    text-decoration: underline;
  }

  .source-badge {
    display: inline-block;
    margin-left: 0.35rem;
    font-size: 0.7rem;
    vertical-align: middle;
    cursor: help;
  }

  .source-player {
    color: var(--accent-secondary, #4ecdc4);
  }

  .source-verified {
    color: #2ecc71;
    font-weight: 700;
  }

  .num {
    font-family: monospace;
    text-align: right;
  }

  .center {
    text-align: center;
  }

  .accel-cell {
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-secondary, #888);
  }

  .rating-cell {
    font-family: monospace;
    text-align: center;
    font-size: 0.8rem;
    white-space: nowrap;
  }

  .rating-cell.duel {
    color: #3498db;
  }

  .rating-cell.team {
    color: #2ecc71;
  }

  .rating-type {
    font-size: 0.65rem;
    color: var(--text-secondary, #888);
    margin-left: 0.25rem;
    opacity: 0.8;
  }

  .hw-cell {
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 0.8rem;
  }

  .hw-link {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: none;
    transition: color 0.2s;
  }

  .hw-link:hover {
    color: var(--accent-primary, #ff6b35);
    text-decoration: underline;
  }

  .date-cell {
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    white-space: nowrap;
  }

  .filters {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 1rem;
  }

  .filter-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .filter-group label {
    color: var(--text-secondary, #888);
    font-size: 0.875rem;
  }

  .filter-group select,
  .search-input {
    background: var(--bg-secondary, #12121a);
    border: 1px solid var(--border-color, #2a2a3a);
    color: var(--text-primary, #fff);
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
  }

  .search-input {
    min-width: 250px;
  }

  @media (max-width: 1024px) {
    .player-table {
      font-size: 0.75rem;
    }

    .player-table th,
    .player-table td {
      padding: 0.4rem 0.5rem;
    }

    .hw-cell {
      max-width: 100px;
    }

    .search-input {
      min-width: 180px;
    }
  }

  @media (max-width: 640px) {
    .filters {
      flex-direction: column;
      align-items: stretch;
    }

    .search-input {
      min-width: 100%;
    }
  }
</style>
