---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';

// Get all players and hardware (filter out unpublished)
const allPlayers = await getCollection('players');
const players = allPlayers.filter(p => p.data.published !== false);
const mice = await getCollection('mice');
const keyboards = await getCollection('keyboards');
const headsets = await getCollection('headsets');
const monitors = await getCollection('monitors');

// Create lookup maps for hardware
const miceMap = new Map(mice.map(m => [m.id, m.data]));
const keyboardsMap = new Map(keyboards.map(k => [k.id, k.data]));
const headsetsMap = new Map(headsets.map(h => [h.id, h.data]));
const monitorsMap = new Map(monitors.map(m => [m.id, m.data]));

// Calculate cm/360 based on m_cpi setting
function calculateCm360(player: any): number {
  if (player.cm360) return player.cm360;
  if (player.m_cpi) {
    // When m_cpi is set: cm360 = 360 × m_cpi / (sensitivity × DPI)
    // When m_cpi = DPI, this simplifies to 360 / sensitivity
    return Math.round((360 * player.m_cpi / (player.sensitivity * player.dpi)) * 100) / 100;
  }
  // Standard calculation: cm360 = 41563.6 / (DPI × sensitivity)
  return Math.round((41563.6 / (player.dpi * player.sensitivity)) * 100) / 100;
}

function formatNum(n: number): string {
  const fixed = n.toFixed(2);
  return fixed.endsWith('.00') ? Math.round(n).toString() : fixed;
}

// Get team rating (higher of CTF or TDM)
function getTeamRating(player: any): { rating: number | null; type: 'ctf' | 'tdm' | null } {
  const ctf = player.ctfRating;
  const tdm = player.tdmRating;
  if (!ctf && !tdm) return { rating: null, type: null };
  if (!ctf) return { rating: tdm, type: 'tdm' };
  if (!tdm) return { rating: ctf, type: 'ctf' };
  return ctf >= tdm ? { rating: ctf, type: 'ctf' } : { rating: tdm, type: 'tdm' };
}

// Format rating for display
function formatRating(rating: number | null, isDuel: boolean): string {
  if (rating === null) return '—';
  return isDuel ? Math.round(rating).toString() : rating.toFixed(1);
}

// Extract model from hardware name by removing brand prefix
function getHardwareDisplay(hwData: any, fallbackSlug: string | undefined): { brand: string | null; model: string; fullName: string } {
  if (!hwData?.name) {
    return { brand: null, model: fallbackSlug || '—', fullName: fallbackSlug || '—' };
  }
  const fullName = hwData.name;
  const brand = hwData.brand;

  if (!brand) {
    return { brand: null, model: fullName, fullName };
  }

  // Extract model by removing brand from start of name
  if (fullName.startsWith(brand)) {
    const model = fullName.slice(brand.length).trim();
    return { brand, model: model || fullName, fullName };
  }

  // Brand doesn't match start of name, show full name
  return { brand: null, model: fullName, fullName };
}

// Sort players by name
const sortedPlayers = players.sort((a, b) => a.data.name.localeCompare(b.data.name));

// Ensure base URL has trailing slash for path concatenation
const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;

const schema = {
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "QL Pro Settings",
  "url": "https://stripyq.github.io/quakesettings/",
  "description": "Quake Live pro player settings and hardware database",
  "publisher": {
    "@type": "Organization",
    "name": "QL Pro Settings"
  }
};
---

<BaseLayout title="Quake Player Database" description="Browse settings, configs, and hardware from 96+ competitive Quake Live players. Find sensitivity, crosshair, keybinds, and gear used by the pros." schema={schema}>
  <div class="page-header">
    <h1>Quake Live Pro Settings</h1>
    <p>Mouse settings, hardware, and configs from {players.length} players</p>
    <a href={`${base}submit/`} class="submit-settings-btn">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>
      Submit Your Settings
    </a>
  </div>

  <div class="filters">
    <div class="filter-group">
      <label for="category-filter">Category:</label>
      <select id="category-filter">
        <option value="all">All Players</option>
        <option value="duel">Duel</option>
        <option value="ctf">CTF</option>
        <option value="tdm">TDM</option>
      </select>
    </div>

    <div class="filter-group">
      <input type="text" id="player-search" placeholder="Search players or hardware..." class="search-input">
    </div>
  </div>

  <div class="table-container">
    <table class="player-table" id="player-table">
      <thead>
        <tr>
          <th class="sortable" data-sort="name">Player</th>
          <th class="sortable" data-sort="duel" title="Duel rating (Glicko from QLStats)">Duel</th>
          <th class="sortable" data-sort="team" title="Team rating (higher of CTF/TDM)">Team</th>
          <th class="sortable" data-sort="mouse">Mouse</th>
          <th class="sortable" data-sort="dpi">DPI</th>
          <th class="sortable" data-sort="sens">Sens</th>
          <th class="sortable" data-sort="cm360" title="cm/360° - distance to complete one full turn">cm/360</th>
          <th class="sortable" data-sort="accel">Accel</th>
          <th class="sortable" data-sort="fov">FOV</th>
          <th>Monitor</th>
          <th>Keyboard</th>
          <th>Headset</th>
          <th class="sortable" data-sort="updated">Updated</th>
        </tr>
      </thead>
      <tbody id="player-tbody">
        {sortedPlayers.map((player) => {
          const mouseData = miceMap.get(player.data.mouse);
          const keyboardData = keyboardsMap.get(player.data.keyboard);
          const headsetData = headsetsMap.get(player.data.headset);
          const monitorData = monitorsMap.get(player.data.monitor);
          const cm360 = calculateCm360(player.data);
          const hasAccel = player.data.acceleration;
          const teamInfo = getTeamRating(player.data);
          const mouseDisplay = getHardwareDisplay(mouseData, player.data.mouse);
          const keyboardDisplay = getHardwareDisplay(keyboardData, player.data.keyboard);
          const headsetDisplay = getHardwareDisplay(headsetData, player.data.headset);
          const monitorDisplay = getHardwareDisplay(monitorData, player.data.monitor);
          return (
            <tr
              class="player-row"
              data-name={player.data.name.toLowerCase()}
              data-category={player.data.category}
              data-dpi={player.data.dpi}
              data-sens={player.data.sensitivity}
              data-cm360={cm360}
              data-fov={player.data.fov}
              data-accel={hasAccel ? "1" : "0"}
              data-duel={player.data.duelRating || 0}
              data-team={teamInfo.rating || 0}
              data-mouse={mouseData?.name?.toLowerCase() || player.data.mouse?.toLowerCase() || ''}
              data-monitor={monitorData?.name?.toLowerCase() || player.data.monitor?.toLowerCase() || ''}
              data-keyboard={keyboardData?.name?.toLowerCase() || player.data.keyboard?.toLowerCase() || ''}
              data-headset={headsetData?.name?.toLowerCase() || player.data.headset?.toLowerCase() || ''}
              data-updated={player.data.lastUpdated || ''}
            >
              <td class="player-cell">
                <a href={`${base}players/${player.id}/`} class="player-link">
                  {player.data.name}
                </a>
              </td>
              <td class="rating-cell duel">{formatRating(player.data.duelRating || null, true)}</td>
              <td class="rating-cell team" title={teamInfo.type ? teamInfo.type.toUpperCase() : ''}>
                {formatRating(teamInfo.rating, false)}
                {teamInfo.type && <span class="rating-type">{teamInfo.type.toUpperCase()}</span>}
              </td>
              <td class="hw-cell hw-cell-wide">
                <div class="hardware-cell">
                  {mouseDisplay.brand && <span class="hardware-brand">{mouseDisplay.brand}</span>}
                  <span class="hardware-model">{mouseDisplay.model}</span>
                </div>
              </td>
              <td class="num">{player.data.dpi}</td>
              <td class="num">{player.data.sensitivity}</td>
              <td class="num">{formatNum(cm360)}</td>
              <td class={`accel-cell ${hasAccel ? 'accel-on' : ''}`}>{hasAccel ? '✓' : '–'}</td>
              <td class="num">{player.data.fov}</td>
              <td class="hw-cell">
                <div class="hardware-cell">
                  {monitorDisplay.brand && <span class="hardware-brand">{monitorDisplay.brand}</span>}
                  <span class="hardware-model">{monitorDisplay.model}</span>
                </div>
              </td>
              <td class="hw-cell">
                <div class="hardware-cell">
                  {keyboardDisplay.brand && <span class="hardware-brand">{keyboardDisplay.brand}</span>}
                  <span class="hardware-model">{keyboardDisplay.model}</span>
                </div>
              </td>
              <td class="hw-cell">
                <div class="hardware-cell">
                  {headsetDisplay.brand && <span class="hardware-brand">{headsetDisplay.brand}</span>}
                  <span class="hardware-model">{headsetDisplay.model}</span>
                </div>
              </td>
              <td class="date-cell">{player.data.lastUpdated || '—'}</td>
            </tr>
          );
        })}
      </tbody>
    </table>
  </div>

  <div class="pagination" id="pagination">
    <button class="page-btn" id="prev-page" disabled>← Prev</button>
    <span class="page-info" id="page-info">Page 1 of 1</span>
    <button class="page-btn" id="next-page">Next →</button>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const searchInput = document.getElementById('player-search') as HTMLInputElement;
      const categoryFilter = document.getElementById('category-filter') as HTMLSelectElement;
      const tbody = document.getElementById('player-tbody');
      const headers = document.querySelectorAll('th.sortable');
      const prevBtn = document.getElementById('prev-page') as HTMLButtonElement;
      const nextBtn = document.getElementById('next-page') as HTMLButtonElement;
      const pageInfo = document.getElementById('page-info');

      const PLAYERS_PER_PAGE = 25;
      let sortCol = 'team';
      let sortAsc = false;
      let currentPage = 1;
      let filteredRows: HTMLTableRowElement[] = [];

      function filterSortAndPaginate() {
        const search = searchInput?.value.toLowerCase() || '';
        const category = categoryFilter?.value || 'all';

        const rows = Array.from(tbody?.querySelectorAll('tr') || []) as HTMLTableRowElement[];

        // Filter rows
        filteredRows = rows.filter(row => {
          const name = row.dataset.name || '';
          const mouse = row.dataset.mouse || '';
          const monitor = row.dataset.monitor || '';
          const keyboard = row.dataset.keyboard || '';
          const headset = row.dataset.headset || '';
          const cat = row.dataset.category || '';

          // Search filter (searches player name and hardware)
          if (search && !name.includes(search) && !mouse.includes(search) && !monitor.includes(search) && !keyboard.includes(search) && !headset.includes(search)) {
            return false;
          }

          // Category filter
          if (category !== 'all' && cat !== category) {
            return false;
          }

          return true;
        });

        // Sort filtered rows
        filteredRows.sort((a, b) => {
          let aVal: string | number, bVal: string | number;
          switch(sortCol) {
            case 'name':
              aVal = a.dataset.name || '';
              bVal = b.dataset.name || '';
              break;
            case 'duel':
              aVal = parseFloat(a.dataset.duel || '0') || 0;
              bVal = parseFloat(b.dataset.duel || '0') || 0;
              break;
            case 'team':
              aVal = parseFloat(a.dataset.team || '0') || 0;
              bVal = parseFloat(b.dataset.team || '0') || 0;
              break;
            case 'mouse':
              aVal = a.dataset.mouse || '';
              bVal = b.dataset.mouse || '';
              break;
            case 'dpi':
              aVal = parseInt(a.dataset.dpi || '0') || 0;
              bVal = parseInt(b.dataset.dpi || '0') || 0;
              break;
            case 'sens':
              aVal = parseFloat(a.dataset.sens || '0') || 0;
              bVal = parseFloat(b.dataset.sens || '0') || 0;
              break;
            case 'cm360':
              aVal = parseFloat(a.dataset.cm360 || '0') || 0;
              bVal = parseFloat(b.dataset.cm360 || '0') || 0;
              break;
            case 'fov':
              aVal = parseInt(a.dataset.fov || '0') || 0;
              bVal = parseInt(b.dataset.fov || '0') || 0;
              break;
            case 'accel':
              aVal = a.dataset.accel || '0';
              bVal = b.dataset.accel || '0';
              break;
            case 'updated':
              aVal = a.dataset.updated || '';
              bVal = b.dataset.updated || '';
              break;
            default:
              aVal = a.dataset.name || '';
              bVal = b.dataset.name || '';
          }

          if (typeof aVal === 'string') {
            return sortAsc ? aVal.localeCompare(bVal as string) : (bVal as string).localeCompare(aVal);
          }
          return sortAsc ? (aVal as number) - (bVal as number) : (bVal as number) - (aVal as number);
        });

        // Apply pagination
        const totalPages = Math.max(1, Math.ceil(filteredRows.length / PLAYERS_PER_PAGE));
        if (currentPage > totalPages) currentPage = totalPages;

        const startIdx = (currentPage - 1) * PLAYERS_PER_PAGE;
        const endIdx = startIdx + PLAYERS_PER_PAGE;

        // Hide all rows first, then show only current page
        rows.forEach(row => row.style.display = 'none');
        filteredRows.slice(startIdx, endIdx).forEach(row => {
          row.style.display = '';
          tbody?.appendChild(row);
        });

        // Update pagination controls
        updatePaginationControls(totalPages);
      }

      function updatePaginationControls(totalPages: number) {
        if (pageInfo) {
          pageInfo.textContent = `Page ${currentPage} of ${totalPages} (${filteredRows.length} players)`;
        }
        if (prevBtn) {
          prevBtn.disabled = currentPage <= 1;
        }
        if (nextBtn) {
          nextBtn.disabled = currentPage >= totalPages;
        }
      }

      function goToPage(page: number) {
        currentPage = page;
        filterSortAndPaginate();
      }

      // Event listeners
      searchInput?.addEventListener('input', () => {
        currentPage = 1; // Reset to first page on search
        filterSortAndPaginate();
      });

      categoryFilter?.addEventListener('change', () => {
        currentPage = 1; // Reset to first page on filter change
        filterSortAndPaginate();
      });

      prevBtn?.addEventListener('click', () => goToPage(currentPage - 1));
      nextBtn?.addEventListener('click', () => goToPage(currentPage + 1));

      headers.forEach(header => {
        header.addEventListener('click', () => {
          const col = (header as HTMLElement).dataset.sort || 'name';
          if (sortCol === col) {
            sortAsc = !sortAsc;
          } else {
            sortCol = col;
            sortAsc = true;
          }

          // Update header styles
          headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
          header.classList.add(sortAsc ? 'sort-asc' : 'sort-desc');

          currentPage = 1; // Reset to first page on sort change
          filterSortAndPaginate();
        });
      });

      // Initial render
      filterSortAndPaginate();
    });
  </script>
</BaseLayout>

<style>
  .page-header {
    text-align: center;
    margin-bottom: 1.5rem;
  }

  .page-header h1 {
    margin-bottom: 0.5rem;
  }

  .page-header p {
    color: var(--text-secondary);
    margin-bottom: 1rem;
  }

  .submit-settings-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: linear-gradient(135deg, var(--accent-primary), #ff8c5a);
    color: white;
    padding: 0.6rem 1.25rem;
    border-radius: 6px;
    font-weight: 600;
    font-size: 0.9rem;
    text-decoration: none;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .submit-settings-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
    color: white;
    text-decoration: none;
  }

  .submit-settings-btn svg {
    width: 16px;
    height: 16px;
  }

  .table-container {
    overflow-x: auto;
    margin-top: 1.5rem;
    -webkit-overflow-scrolling: touch;
  }

  .player-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
  }

  .player-table th,
  .player-table td {
    padding: 0.4rem 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--border-color, #2a2a3a);
  }

  .player-table th {
    background: var(--bg-secondary, #12121a);
    font-weight: 600;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    white-space: nowrap;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .player-table th.sortable {
    cursor: pointer;
    user-select: none;
  }

  .player-table th.sortable:hover {
    color: var(--accent-primary, #ff6b35);
  }

  .player-table th.sortable::after {
    content: ' ↕';
    opacity: 0.3;
  }

  .player-table th.sort-asc::after {
    content: ' ↑';
    opacity: 1;
  }

  .player-table th.sort-desc::after {
    content: ' ↓';
    opacity: 1;
  }

  .header-info {
    font-size: 0.65rem;
    opacity: 0.6;
    cursor: help;
    margin-left: 0.25rem;
  }

  /* Zebra striping */
  .player-table tbody tr:nth-child(odd) {
    background: rgba(255, 255, 255, 0.02);
  }

  .player-table tbody tr:nth-child(even) {
    background: transparent;
  }

  .player-table tbody tr:hover {
    background: var(--bg-secondary, #12121a);
  }

  .player-link {
    color: var(--accent-primary, #ff6b35);
    text-decoration: none;
    font-weight: 500;
  }

  .player-link:hover {
    text-decoration: underline;
  }

  .player-cell {
    width: 140px;
    min-width: 140px;
    max-width: 140px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .source-badge {
    display: inline-block;
    margin-left: 0.35rem;
    font-size: 0.7rem;
    vertical-align: middle;
    cursor: help;
  }

  .source-player {
    color: var(--accent-secondary, #4ecdc4);
  }

  .source-verified {
    color: #2ecc71;
    font-weight: 700;
  }

  .num {
    font-family: monospace;
    text-align: right;
    white-space: nowrap;
    width: 55px;
    max-width: 55px;
  }

  .center {
    text-align: center;
  }

  .accel-cell {
    text-align: center;
    font-size: 0.9rem;
    color: var(--text-secondary, #555);
    width: 45px;
    max-width: 45px;
  }

  .accel-cell.accel-on {
    color: var(--accent-secondary, #4ecdc4);
    font-weight: 600;
  }

  .pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-top: 1.5rem;
    padding: 1rem 0;
  }

  .page-btn {
    background: var(--bg-secondary, #12121a);
    border: 1px solid var(--border-color, #2a2a3a);
    color: var(--text-primary, #fff);
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
  }

  .page-btn:hover:not(:disabled) {
    background: var(--accent-primary, #ff6b35);
    border-color: var(--accent-primary, #ff6b35);
  }

  .page-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .page-info {
    color: var(--text-secondary, #888);
    font-size: 0.85rem;
  }

  .rating-cell {
    font-family: monospace;
    text-align: center;
    font-size: 0.8rem;
    white-space: nowrap;
  }

  .rating-cell.duel {
    color: #a8a8b0; /* Warm gray - data value, not a link */
  }

  .rating-cell.team {
    color: #9898a8; /* Cool gray - data value, not a link */
  }

  .rating-type {
    font-size: 0.65rem;
    color: #707080; /* Muted - CTF/TDM label */
    margin-left: 0.25rem;
  }

  .hw-cell {
    max-width: 180px;
    overflow: hidden;
    font-size: 0.8rem;
    vertical-align: middle;
  }

  .hw-cell-wide {
    max-width: 220px;
  }

  .hw-link {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: none;
    transition: color 0.2s;
  }

  .hw-link:hover {
    color: var(--accent-primary, #ff6b35);
    text-decoration: underline;
  }

  .hardware-cell {
    display: flex;
    flex-direction: column;
    justify-content: center;
    line-height: 1.15;
    gap: 1px;
  }

  .hardware-brand {
    font-size: 0.65em;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    letter-spacing: 0.02em;
    margin: 0;
  }

  .hardware-model {
    font-size: 0.85em;
    color: var(--text-primary, #fff);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin: 0;
  }

  .date-cell {
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    white-space: nowrap;
  }

  .filters {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 1rem;
  }

  .filter-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .filter-group label {
    color: var(--text-secondary, #888);
    font-size: 0.875rem;
  }

  .filter-group select,
  .search-input {
    background: var(--bg-secondary, #12121a);
    border: 1px solid var(--border-color, #2a2a3a);
    color: var(--text-primary, #fff);
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
  }

  .search-input {
    min-width: 250px;
  }

  @media (max-width: 1024px) {
    .player-table {
      font-size: 0.75rem;
    }

    .player-table th,
    .player-table td {
      padding: 0.3rem 0.5rem;
    }

    .player-cell {
      width: 110px;
      min-width: 110px;
      max-width: 110px;
    }

    .hw-cell {
      max-width: 120px;
    }

    .hw-cell-wide {
      max-width: 150px;
    }

    .num {
      width: 45px;
      max-width: 45px;
    }

    .search-input {
      min-width: 180px;
    }
  }

  @media (max-width: 640px) {
    .filters {
      flex-direction: column;
      align-items: stretch;
    }

    .search-input {
      min-width: 100%;
    }
  }
</style>
