---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';

const players = await getCollection('players');
const mice = await getCollection('mice');
const monitors = await getCollection('monitors');
const keyboards = await getCollection('keyboards');
const mousepads = await getCollection('mousepads');

// Create lookup maps
const miceMap = new Map(mice.map(m => [m.id, m.data]));
const monitorsMap = new Map(monitors.map(m => [m.id, m.data]));
const keyboardsMap = new Map(keyboards.map(k => [k.id, k.data]));
const mousepadsMap = new Map(mousepads.map(p => [p.id, p.data]));

// Calculate cm/360 for a player
function calculateCm360(playerData: any): number {
  if (playerData.cm360) return playerData.cm360;
  if (playerData.m_cpi) {
    return Math.round((360 / playerData.sensitivity) * 100) / 100;
  }
  return Math.round((41563.6 / (playerData.dpi * playerData.sensitivity)) * 100) / 100;
}

// ===========================================
// SENSITIVITY STATS
// ===========================================

// cm/360 calculations (includes all players - cm/360 is base sensitivity, accel is applied on top)
const cm360Values = players.map(p => calculateCm360(p.data)).sort((a, b) => a - b);
const avgCm360 = cm360Values.length > 0
  ? Math.round((cm360Values.reduce((a, b) => a + b, 0) / cm360Values.length) * 100) / 100
  : 0;
const medianCm360 = cm360Values.length > 0
  ? cm360Values[Math.floor(cm360Values.length / 2)]
  : 0;
const minCm360 = cm360Values.length > 0 ? Math.min(...cm360Values) : 0;
const maxCm360 = cm360Values.length > 0 ? Math.max(...cm360Values) : 0;

// eDPI stats
const edpiValues = players.map(p => p.data.edpi).filter(v => v).sort((a, b) => a - b);
const avgEdpi = Math.round(edpiValues.reduce((a, b) => a + b, 0) / edpiValues.length);
const medianEdpi = edpiValues.length > 0 ? edpiValues[Math.floor(edpiValues.length / 2)] : 0;
const minEdpi = Math.min(...edpiValues);
const maxEdpi = Math.max(...edpiValues);

// DPI distribution
const dpiValues = players.map(p => p.data.dpi).filter(v => v);
const avgDpi = Math.round(dpiValues.reduce((a, b) => a + b, 0) / dpiValues.length);
const dpiDistribution = new Map<number, number>();
dpiValues.forEach(dpi => {
  // Round to common DPI values
  const rounded = [400, 800, 1600, 3200].reduce((prev, curr) =>
    Math.abs(curr - dpi) < Math.abs(prev - dpi) ? curr : prev
  );
  dpiDistribution.set(rounded, (dpiDistribution.get(rounded) || 0) + 1);
});
const topDpiValues = [...dpiDistribution.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 4);

// Sensitivity distribution by cm/360
const lowSens = cm360Values.filter(v => v > 35).length; // High cm/360 = low sens
const midSens = cm360Values.filter(v => v >= 20 && v <= 35).length;
const highSens = cm360Values.filter(v => v < 20).length; // Low cm/360 = high sens
const totalSensPlayers = cm360Values.length;

// ===========================================
// HARDWARE POPULARITY
// ===========================================

// Mice
const mouseUsage = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    mouseUsage.set(p.data.mouse, (mouseUsage.get(p.data.mouse) || 0) + 1);
  }
});
const topMice = [...mouseUsage.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([id, count]) => ({
    name: miceMap.get(id)?.name || id,
    count,
    percentage: Math.round((count / players.length) * 100)
  }));

// Monitors by refresh rate
const monitorRefreshRates = new Map<string, number>();
players.forEach(p => {
  if (p.data.monitor) {
    const monitor = monitorsMap.get(p.data.monitor);
    const refreshRate = monitor?.refreshRate || 'Unknown';
    monitorRefreshRates.set(refreshRate, (monitorRefreshRates.get(refreshRate) || 0) + 1);
  }
});
const topRefreshRates = [...monitorRefreshRates.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Keyboard brands
const keyboardBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.keyboard) {
    const kb = keyboardsMap.get(p.data.keyboard);
    const brand = kb?.brand || 'Unknown';
    keyboardBrands.set(brand, (keyboardBrands.get(brand) || 0) + 1);
  }
});
const topKeyboardBrands = [...keyboardBrands.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Mousepad brands
const mousepadBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    const brand = pad?.brand || 'Unknown';
    mousepadBrands.set(brand, (mousepadBrands.get(brand) || 0) + 1);
  }
});
const topMousepadBrands = [...mousepadBrands.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// GPU Brand distribution
const gpuBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.gpuBrand) {
    gpuBrands.set(p.data.gpuBrand, (gpuBrands.get(p.data.gpuBrand) || 0) + 1);
  }
});
const topGpuBrands = [...gpuBrands.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalGpuPlayers = [...gpuBrands.values()].reduce((a, b) => a + b, 0);

// CPU Brand distribution
const cpuBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.cpuBrand) {
    cpuBrands.set(p.data.cpuBrand, (cpuBrands.get(p.data.cpuBrand) || 0) + 1);
  }
});
const topCpuBrands = [...cpuBrands.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalCpuPlayers = [...cpuBrands.values()].reduce((a, b) => a + b, 0);

// ===========================================
// SETTINGS TRENDS
// ===========================================

// FOV distribution
const fovValues = players.map(p => p.data.fov).filter(v => v);
const avgFov = Math.round(fovValues.reduce((a, b) => a + b, 0) / fovValues.length);
const fovDistribution = new Map<number, number>();
fovValues.forEach(fov => {
  fovDistribution.set(fov, (fovDistribution.get(fov) || 0) + 1);
});
const topFovValues = [...fovDistribution.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Acceleration users
const accelUsers = players.filter(p => p.data.acceleration).length;
const accelPercentage = Math.round((accelUsers / players.length) * 100);

// m_cpi users
const mcpiUsers = players.filter(p => p.data.m_cpi).length;
const mcpiPercentage = Math.round((mcpiUsers / players.length) * 100);

// Crosshair types
const crosshairTypes = new Map<string, number>();
players.forEach(p => {
  const ch = p.data.crosshair || 'Unknown';
  crosshairTypes.set(ch, (crosshairTypes.get(ch) || 0) + 1);
});
const topCrosshairs = [...crosshairTypes.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// ===========================================
// PLAYER STATS
// ===========================================

// Categories
const categoryDuel = players.filter(p => p.data.category === 'duel').length;
const categoryCTF = players.filter(p => p.data.category === 'ctf').length;
const categoryTDM = players.filter(p => p.data.category === 'tdm').length;
const categoryOther = players.length - categoryDuel - categoryCTF - categoryTDM;

// Recently updated (sort by lastUpdated)
const recentPlayers = [...players]
  .filter(p => p.data.lastUpdated)
  .sort((a, b) => (b.data.lastUpdated || '').localeCompare(a.data.lastUpdated || ''))
  .slice(0, 5);

// ===========================================
// INTERESTING FACTS
// ===========================================

// Lowest sens player (highest cm/360)
const lowestSensPlayer = players.reduce((prev, curr) =>
  calculateCm360(curr.data) > calculateCm360(prev.data) ? curr : prev
);

// Highest sens player (lowest cm/360)
const highestSensPlayer = players.reduce((prev, curr) =>
  calculateCm360(curr.data) < calculateCm360(prev.data) ? curr : prev
);

// ===========================================
// MOUSE SHAPE & SIZE STATISTICS
// ===========================================

// Mouse shape distribution
const mouseShapeDistribution = new Map<string, number>();
const mouseWeightDistribution = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    const mouseData = miceMap.get(p.data.mouse);
    if (mouseData) {
      // Shape
      const shape = mouseData.shape || 'Unknown';
      mouseShapeDistribution.set(shape, (mouseShapeDistribution.get(shape) || 0) + 1);

      // Weight (categorize)
      if (mouseData.weight && mouseData.weight !== 'Unknown') {
        const weightNum = parseFloat(mouseData.weight);
        let weightCategory = 'Unknown';
        if (weightNum < 70) weightCategory = 'Ultralight (<70g)';
        else if (weightNum < 90) weightCategory = 'Light (70-89g)';
        else if (weightNum < 110) weightCategory = 'Medium (90-109g)';
        else weightCategory = 'Heavy (110g+)';
        mouseWeightDistribution.set(weightCategory, (mouseWeightDistribution.get(weightCategory) || 0) + 1);
      }
    }
  }
});

const topMouseShapes = [...mouseShapeDistribution.entries()]
  .sort((a, b) => b[1] - a[1]);
const topMouseWeights = [...mouseWeightDistribution.entries()]
  .sort((a, b) => {
    // Sort by weight category order
    const order = ['Ultralight (<70g)', 'Light (70-89g)', 'Medium (90-109g)', 'Heavy (110g+)', 'Unknown'];
    return order.indexOf(a[0]) - order.indexOf(b[0]);
  });

// ===========================================
// MONITOR SIZE VS REFRESH RATE HEATMAP
// ===========================================

// Parse size to number (e.g., "27 inch" or "27\"" -> 27)
function parseMonitorSize(size: string): number | null {
  const match = size.match(/(\d+(?:\.\d+)?)/);
  return match ? parseFloat(match[1]) : null;
}

// Parse refresh rate to number (e.g., "360Hz" -> 360)
function parseRefreshRate(rate: string): number | null {
  const match = rate.match(/(\d+)/);
  return match ? parseInt(match[1]) : null;
}

// Define bins for the heatmap
const sizeBins = [18, 21, 23, 24, 25, 27, 28, 32, 34];
const refreshBins = [60, 120, 144, 165, 180, 240, 280, 360, 500];

// Build heatmap data
const monitorHeatmap: Map<string, number> = new Map();
players.forEach(p => {
  if (p.data.monitor) {
    const monitorData = monitorsMap.get(p.data.monitor);
    if (monitorData) {
      const size = parseMonitorSize(monitorData.size || '');
      const refresh = parseRefreshRate(monitorData.refreshRate || '');

      if (size !== null && refresh !== null) {
        // Find closest size bin
        const sizeBin = sizeBins.reduce((prev, curr) =>
          Math.abs(curr - size) < Math.abs(prev - size) ? curr : prev
        );
        // Find closest refresh bin
        const refreshBin = refreshBins.reduce((prev, curr) =>
          Math.abs(curr - refresh) < Math.abs(prev - refresh) ? curr : prev
        );

        const key = `${sizeBin}-${refreshBin}`;
        monitorHeatmap.set(key, (monitorHeatmap.get(key) || 0) + 1);
      }
    }
  }
});

// Calculate max for color scaling
const heatmapMax = Math.max(...monitorHeatmap.values(), 1);

// ===========================================
// KEY BINDINGS STATISTICS
// ===========================================

// Movement keys analysis
const movementPatterns = new Map<string, number>();
const jumpKeys = new Map<string, number>();

players.forEach(p => {
  // Analyze movement pattern
  const forward = (p.data.forward || 'W').toUpperCase();
  const left = (p.data.left || 'A').toUpperCase();
  const back = (p.data.back || 'S').toUpperCase();
  const right = (p.data.right || 'D').toUpperCase();

  let pattern = `${forward}${left}${back}${right}`;

  // Normalize common patterns
  if (pattern === 'WASD') pattern = 'WASD';
  else if (pattern === 'ESDF') pattern = 'ESDF';
  else if (pattern === 'RFDG') pattern = 'RFDG';
  else if (forward.includes('ARROW') || forward.includes('UP')) pattern = 'Arrow Keys';
  else if (forward.includes('KP_') || forward.includes('NUMPAD')) pattern = 'Numpad';

  movementPatterns.set(pattern, (movementPatterns.get(pattern) || 0) + 1);

  // Analyze jump key
  let jump = (p.data.jump || 'Space');
  // Normalize
  if (jump.toLowerCase() === 'space' || jump.toLowerCase() === 'spacebar') jump = 'Space';
  else if (jump.toLowerCase().includes('mouse2') || jump.toLowerCase() === 'mwheeldown' || jump.toLowerCase() === 'm2') jump = 'Mouse2';
  else if (jump.toLowerCase().includes('mouse')) jump = 'Mouse Button';
  else if (jump.toLowerCase() === 'shift') jump = 'Shift';
  else if (jump.toLowerCase() === 'ctrl' || jump.toLowerCase() === 'control') jump = 'Ctrl';

  jumpKeys.set(jump, (jumpKeys.get(jump) || 0) + 1);
});

const topMovementPatterns = [...movementPatterns.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const topJumpKeys = [...jumpKeys.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 6);

// Format bind strings to add space after MOUSE1/MOUSE2
function formatBindString(bind: string): string {
  return bind.replace(/^(MOUSE[12])([A-Z])/, '$1 $2');
}

// ===========================================
// CROSSHAIR VISUALIZATION DATA
// ===========================================

// Crosshair type to visual description mapping
const crosshairVisuals: Record<string, { shape: string; description: string }> = {
  '1': { shape: 'circle-dot', description: 'Circle with dot' },
  '2': { shape: 'cross', description: 'Cross (+)' },
  '3': { shape: 'cross-gap', description: 'Cross with gap' },
  '4': { shape: 'dot', description: 'Small dot' },
  '5': { shape: 'dot-large', description: 'Large dot' },
  '6': { shape: 'dot', description: 'Dot' },
  '7': { shape: 'cross-thick', description: 'Thick cross' },
  '8': { shape: 'circle', description: 'Circle' },
  '9': { shape: 'cross-gap', description: 'Cross with gap' },
  '10': { shape: 'x-mark', description: 'X shape' },
  '11': { shape: 'triangle', description: 'Triangle' },
  '12': { shape: 'chevron', description: 'Chevron' },
  '13': { shape: 'circle-crosshair', description: 'Circle crosshair' },
};

// Get crosshair data with counts
const crosshairData = [...crosshairTypes.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([type, count]) => ({
    type,
    count,
    percentage: Math.round((count / players.length) * 100),
    visual: crosshairVisuals[type] || { shape: 'unknown', description: `Type ${type}` }
  }));

// Ensure base URL has trailing slash
const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;
---

<BaseLayout title="Statistics">
  <div class="page-header">
    <h1>Player Statistics</h1>
    <p>Aggregated data from {players.length} Quake Live players</p>
  </div>

  <div class="stats-container">
    <!-- ========== SENSITIVITY SECTION ========== -->
    <section class="stat-card wide">
      <h2>Sensitivity Overview</h2>
      <div class="stat-row">
        <div class="big-stat">
          <span class="stat-number">{avgCm360.toFixed(2)}</span>
          <span class="stat-label">Average cm/360</span>
        </div>
        <div class="big-stat">
          <span class="stat-number">{medianCm360.toFixed(2)}</span>
          <span class="stat-label">Median cm/360</span>
        </div>
        <div class="big-stat">
          <span class="stat-number">{avgEdpi}</span>
          <span class="stat-label">Average eDPI</span>
        </div>
        <div class="big-stat">
          <span class="stat-number">{medianEdpi}</span>
          <span class="stat-label">Median eDPI</span>
        </div>
      </div>
      <div class="stat-details">
        <div><strong>cm/360 Range:</strong> {minCm360.toFixed(2)} - {maxCm360.toFixed(2)}</div>
        <div><strong>eDPI Range:</strong> {minEdpi} - {maxEdpi}</div>
      </div>
      <div class="sensitivity-info">
        <p><strong>cm/360¬∞</strong> = how many centimeters it takes for you to complete a 360 degree turn. This is also called your real sensitivity.</p>
        <p><strong>eDPI</strong> = mouse DPI √ó ingame sens</p>
        <ul class="disclaimer-list">
          <li><em>Disclaimer:</em> for these calculations default windows sensitivity multiplier, default m_yaw and m_cpi was used</li>
          <li>Does not account for in-game acceleration. If mouse acceleration is enabled, the movement distance required to turn 360¬∞ will of course vary depending on the speed of your mouse movement. But can still be used as comparable "base" sensitivity.</li>
        </ul>
      </div>
    </section>

    <div class="two-col">
      <!-- SENSITIVITY DISTRIBUTION -->
      <section class="stat-card">
        <h2>Sensitivity Distribution</h2>
        <p class="card-subtitle">Based on cm/360 values</p>
        <div class="distribution">
          <div class="dist-bar">
            <div class="dist-fill low" style={`width: ${(lowSens / totalSensPlayers) * 100}%`}></div>
            <span>Low (&gt;35cm): {lowSens} ({Math.round((lowSens / totalSensPlayers) * 100)}%)</span>
          </div>
          <div class="dist-bar">
            <div class="dist-fill mid" style={`width: ${(midSens / totalSensPlayers) * 100}%`}></div>
            <span>Medium (20-35cm): {midSens} ({Math.round((midSens / totalSensPlayers) * 100)}%)</span>
          </div>
          <div class="dist-bar">
            <div class="dist-fill high" style={`width: ${(highSens / totalSensPlayers) * 100}%`}></div>
            <span>High (&lt;20cm): {highSens} ({Math.round((highSens / totalSensPlayers) * 100)}%)</span>
          </div>
        </div>
      </section>

      <!-- DPI DISTRIBUTION -->
      <section class="stat-card">
        <h2>DPI Distribution</h2>
        <div class="popularity-list">
          {topDpiValues.map(([dpi, count]) => (
            <div class="popularity-item">
              <span class="name">{dpi} DPI</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / players.length) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <!-- ========== HARDWARE SECTION ========== -->
    <h3 class="section-header">Hardware</h3>

    <div class="two-col">
      <!-- TOP MICE -->
      <section class="stat-card">
        <h2>Most Popular Mice</h2>
        <div class="popularity-list">
          {topMice.slice(0, 5).map((mouse, i) => (
            <div class="popularity-item">
              <span class="rank">#{i + 1}</span>
              <span class="name">{mouse.name}</span>
              <span class="count">{mouse.count} ({mouse.percentage}%)</span>
            </div>
          ))}
        </div>
        {topMice.length > 5 && (
          <details class="more-items">
            <summary>Show more</summary>
            <div class="popularity-list">
              {topMice.slice(5).map((mouse, i) => (
                <div class="popularity-item">
                  <span class="rank">#{i + 6}</span>
                  <span class="name">{mouse.name}</span>
                  <span class="count">{mouse.count} ({mouse.percentage}%)</span>
                </div>
              ))}
            </div>
          </details>
        )}
      </section>

      <!-- MOUSE SHAPE & WEIGHT -->
      <section class="stat-card">
        <h2>Mouse Shape & Weight</h2>
        <h3 class="subsection-title">Shape Preference</h3>
        <div class="popularity-list compact">
          {topMouseShapes.map(([shape, count]) => (
            <div class="popularity-item">
              <span class="name">{shape}</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / players.length) * 100)}%)</span>
            </div>
          ))}
        </div>
        <h3 class="subsection-title">Weight Distribution</h3>
        <div class="popularity-list compact">
          {topMouseWeights.map(([weight, count]) => (
            <div class="popularity-item">
              <span class="name">{weight}</span>
              <div class="bar-wrapper">
                <div class="bar-fill accent" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / players.length) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <div class="two-col">
      <!-- MONITOR REFRESH RATES -->
      <section class="stat-card">
        <h2>Monitor Refresh Rates</h2>
        <div class="popularity-list">
          {topRefreshRates.map(([rate, count]) => (
            <div class="popularity-item">
              <span class="name">{rate}</span>
              <div class="bar-wrapper">
                <div class="bar-fill accent" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / players.length) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>

      <!-- KEYBOARD & MOUSEPAD BRANDS -->
      <section class="stat-card">
        <h2>Other Hardware</h2>
        <h3 class="subsection-title">Top Keyboard Brands</h3>
        <div class="popularity-list compact">
          {topKeyboardBrands.map(([brand, count]) => (
            <div class="popularity-item">
              <span class="name">{brand}</span>
              <span class="count">{count}</span>
            </div>
          ))}
        </div>
        <h3 class="subsection-title">Top Mousepad Brands</h3>
        <div class="popularity-list compact">
          {topMousepadBrands.map(([brand, count]) => (
            <div class="popularity-item">
              <span class="name">{brand}</span>
              <span class="count">{count}</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <div class="two-col">
      <!-- GPU BRAND -->
      <section class="stat-card">
        <h2>GPU Brand</h2>
        <p class="card-subtitle">{totalGpuPlayers} players with data</p>
        <div class="popularity-list">
          {topGpuBrands.map(([brand, count]) => (
            <div class="popularity-item">
              <span class="name">{brand}</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / totalGpuPlayers) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / totalGpuPlayers) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>

      <!-- CPU BRAND -->
      <section class="stat-card">
        <h2>CPU Brand</h2>
        <p class="card-subtitle">{totalCpuPlayers} players with data</p>
        <div class="popularity-list">
          {topCpuBrands.map(([brand, count]) => (
            <div class="popularity-item">
              <span class="name">{brand}</span>
              <div class="bar-wrapper">
                <div class="bar-fill accent" style={`width: ${(count / totalCpuPlayers) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / totalCpuPlayers) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <!-- MONITOR SIZE VS REFRESH RATE HEATMAP -->
    <section class="stat-card wide">
      <h2>Monitor Size vs Refresh Rate</h2>
      <p class="card-subtitle">Heatmap showing player monitor preferences</p>
      <div class="heatmap-container">
        <div class="heatmap-y-label">Size (inches)</div>
        <div class="heatmap-wrapper">
          <div class="heatmap-grid" style={`grid-template-columns: auto repeat(${refreshBins.length}, 1fr)`}>
            <!-- Header row -->
            <div class="heatmap-cell header"></div>
            {refreshBins.map(rate => (
              <div class="heatmap-cell header">{rate}</div>
            ))}

            <!-- Data rows -->
            {[...sizeBins].reverse().map(size => (
              <>
                <div class="heatmap-cell row-label">{size}"</div>
                {refreshBins.map(rate => {
                  const count = monitorHeatmap.get(`${size}-${rate}`) || 0;
                  const intensity = count / heatmapMax;
                  return (
                    <div
                      class="heatmap-cell data"
                      style={`background-color: ${count > 0 ? `rgba(78, 205, 196, ${0.2 + intensity * 0.8})` : 'var(--bg-secondary)'}`}
                      title={`${size}" @ ${rate}Hz: ${count} players`}
                    >
                      {count > 0 ? count : ''}
                    </div>
                  );
                })}
              </>
            ))}
          </div>
          <div class="heatmap-x-label">Refresh Rate (Hz)</div>
        </div>
        <div class="heatmap-legend">
          <span class="legend-label">Low</span>
          <div class="legend-gradient"></div>
          <span class="legend-label">High</span>
        </div>
      </div>
    </section>

    <!-- ========== SETTINGS SECTION ========== -->
    <h3 class="section-header">Settings & Controls</h3>

    <div class="three-col">
      <!-- SETTINGS TRENDS -->
      <section class="stat-card">
        <h2>Settings Trends</h2>
        <div class="trend-stats">
          <div class="trend-item">
            <span class="trend-value">{avgFov}¬∞</span>
            <span class="trend-label">Average FOV</span>
          </div>
          <div class="trend-item">
            <span class="trend-value">{accelPercentage}%</span>
            <span class="trend-label">Use Acceleration</span>
          </div>
          <div class="trend-item">
            <span class="trend-value">{mcpiPercentage}%</span>
            <span class="trend-label">Use m_cpi</span>
          </div>
        </div>
        <h3 class="subsection-title">Top FOV Values</h3>
        <div class="popularity-list compact">
          {topFovValues.map(([fov, count]) => (
            <div class="popularity-item">
              <span class="name">{fov}¬∞</span>
              <span class="count">{count} players</span>
            </div>
          ))}
        </div>
      </section>

      <!-- KEY BINDINGS - MOVEMENT -->
      <section class="stat-card">
        <h2>Movement Keys</h2>
        <div class="binds-list">
          {topMovementPatterns.map(([pattern, count]) => (
            <div class="bind-item">
              <span class="bind-keys">{formatBindString(pattern)}</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </section>

      <!-- KEY BINDINGS - JUMP -->
      <section class="stat-card">
        <h2>Jump Key</h2>
        <div class="binds-list">
          {topJumpKeys.map(([key, count]) => (
            <div class="bind-item">
              <span class="bind-keys">{key}</span>
              <div class="bar-wrapper">
                <div class="bar-fill accent" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <!-- CROSSHAIR TYPES WITH VISUALS -->
    <section class="stat-card wide">
      <h2>Crosshair Styles</h2>
      <p class="card-subtitle">cg_drawCrosshair values and visual representation</p>
      <div class="crosshair-grid">
        {crosshairData.map(({ type, count, percentage, visual }) => (
          <div class="crosshair-item">
            <div class="crosshair-preview" data-type={visual.shape}>
              {visual.shape === 'cross' && <div class="ch ch-cross"></div>}
              {visual.shape === 'cross-thick' && <div class="ch ch-cross-thick"></div>}
              {visual.shape === 'cross-gap' && <div class="ch ch-cross-gap"></div>}
              {visual.shape === 'dot' && <div class="ch ch-dot"></div>}
              {visual.shape === 'dot-large' && <div class="ch ch-dot-large"></div>}
              {visual.shape === 'circle' && <div class="ch ch-circle"></div>}
              {visual.shape === 'circle-dot' && <div class="ch ch-circle-dot"></div>}
              {visual.shape === 'circle-crosshair' && <div class="ch ch-circle-crosshair"></div>}
              {visual.shape === 'x-mark' && <div class="ch ch-x"></div>}
              {visual.shape === 'triangle' && <div class="ch ch-triangle"></div>}
              {visual.shape === 'chevron' && <div class="ch ch-chevron"></div>}
              {visual.shape === 'unknown' && <div class="ch ch-unknown">?</div>}
            </div>
            <div class="crosshair-info">
              <span class="crosshair-type">Type {type}</span>
              <span class="crosshair-count">{count} ({percentage}%)</span>
            </div>
          </div>
        ))}
      </div>
    </section>

    <!-- ========== PLAYERS SECTION ========== -->
    <h3 class="section-header">Players</h3>

    <div class="three-col">
      <!-- PLAYER CATEGORIES -->
      <section class="stat-card">
        <h2>Players by Category</h2>
        <div class="category-grid">
          <div class="category-item">
            <span class="category-count">{categoryDuel}</span>
            <span class="category-label">Duel</span>
          </div>
          <div class="category-item">
            <span class="category-count">{categoryCTF}</span>
            <span class="category-label">CTF</span>
          </div>
          <div class="category-item">
            <span class="category-count">{categoryTDM}</span>
            <span class="category-label">TDM</span>
          </div>
          {categoryOther > 0 && (
            <div class="category-item">
              <span class="category-count">{categoryOther}</span>
              <span class="category-label">Other</span>
            </div>
          )}
        </div>
      </section>

      <!-- RECENTLY UPDATED -->
      {recentPlayers.length > 0 && (
        <section class="stat-card">
          <h2>Recently Updated</h2>
          <div class="recent-list">
            {recentPlayers.map(p => (
              <div class="recent-item">
                <a href={`${base}players/${p.id}/`}>{p.data.name}</a>
                <span class="date">{p.data.lastUpdated}</span>
              </div>
            ))}
          </div>
        </section>
      )}

      <!-- INTERESTING FACTS -->
      <section class="stat-card highlight">
        <h2>Interesting Facts</h2>
        <div class="facts-list">
          <div class="fact-item">
            <span class="fact-icon">üê¢</span>
            <div class="fact-content">
              <strong>Lowest Sensitivity</strong>
              <p>
                <a href={`${base}players/${lowestSensPlayer.id}/`}>{lowestSensPlayer.data.name}</a>
                uses {calculateCm360(lowestSensPlayer.data).toFixed(2)} cm/360
              </p>
            </div>
          </div>
          <div class="fact-item">
            <span class="fact-icon">‚ö°</span>
            <div class="fact-content">
              <strong>Highest Sensitivity</strong>
              <p>
                <a href={`${base}players/${highestSensPlayer.id}/`}>{highestSensPlayer.data.name}</a>
                uses {calculateCm360(highestSensPlayer.data).toFixed(2)} cm/360
              </p>
            </div>
          </div>
          <div class="fact-item">
            <span class="fact-icon">üìä</span>
            <div class="fact-content">
              <strong>Total Players</strong>
              <p>{players.length} players in the database</p>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <footer class="stats-footer">
    <p>Duel ratings via <a href="https://qlstats.net/ranks/duel/1" target="_blank" rel="noopener">QLStats</a> ‚Ä¢ CTF/TDM ratings via <a href="http://88.214.20.58/ratings/" target="_blank" rel="noopener">HoQ community tracker</a></p>
  </footer>
</BaseLayout>

<style>
  .stats-container {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .section-header {
    font-size: 0.9rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin: 1rem 0 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .two-col {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }

  .three-col {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1.5rem;
  }

  @media (max-width: 900px) {
    .three-col {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 700px) {
    .two-col,
    .three-col {
      grid-template-columns: 1fr;
    }
  }

  .stat-card {
    background: var(--bg-card, #1a1a24);
    border-radius: 8px;
    padding: 1.5rem;
    border: 1px solid var(--border-color, #2a2a35);
  }

  .stat-card.wide {
    width: 100%;
  }

  .stat-card.highlight {
    border-color: var(--accent-primary, #ff6b35);
    background: linear-gradient(135deg, var(--bg-card, #1a1a24) 0%, rgba(255, 107, 53, 0.05) 100%);
  }

  .stat-card h2 {
    font-size: 1rem;
    margin-bottom: 1rem;
    color: var(--accent-primary, #ff6b35);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .card-subtitle {
    font-size: 0.8rem;
    color: var(--text-secondary, #888);
    margin-top: -0.75rem;
    margin-bottom: 1rem;
  }

  .stat-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .big-stat {
    text-align: center;
    padding: 1rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .stat-number {
    display: block;
    font-size: 1.75rem;
    font-weight: 700;
    color: var(--accent-secondary, #4ecdc4);
  }

  .stat-label {
    display: block;
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.25rem;
  }

  .stat-details {
    font-size: 0.85rem;
    color: var(--text-secondary, #ccc);
  }

  .stat-details div {
    margin-bottom: 0.25rem;
  }

  .stat-note {
    font-size: 0.75rem;
    color: var(--text-secondary, #666);
    margin-top: 0.75rem;
    font-style: italic;
  }

  .sensitivity-info {
    margin-top: 1.25rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color, #2a2a35);
    font-size: 0.85rem;
    color: var(--text-secondary, #a0a0b0);
  }

  .sensitivity-info p {
    margin: 0 0 0.5rem 0;
  }

  .disclaimer-list {
    margin: 0.75rem 0 0 0;
    padding-left: 1.25rem;
    list-style-type: disc;
  }

  .disclaimer-list li {
    margin-bottom: 0.35rem;
    line-height: 1.4;
  }

  .disclaimer-list em {
    color: var(--accent-primary, #ff6b35);
  }

  .distribution {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .dist-bar {
    position: relative;
    height: 2rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 4px;
    overflow: hidden;
  }

  .dist-fill {
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s ease;
  }

  .dist-fill.low { background: #3498db; }
  .dist-fill.mid { background: #2ecc71; }
  .dist-fill.high { background: #e74c3c; }

  .dist-bar span {
    position: absolute;
    left: 0.5rem;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.8rem;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    z-index: 1;
  }

  .popularity-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .popularity-list.compact {
    gap: 0.35rem;
  }

  .popularity-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.35rem 0;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .popularity-item:last-child {
    border-bottom: none;
  }

  .rank {
    font-weight: 700;
    color: var(--accent-primary, #ff6b35);
    min-width: 2rem;
  }

  .name {
    flex: 1;
    font-size: 0.9rem;
  }

  .count {
    font-size: 0.8rem;
    color: var(--text-secondary, #888);
    text-align: right;
  }

  .bar-wrapper {
    flex: 1;
    height: 6px;
    background: var(--bg-secondary, #12121a);
    border-radius: 3px;
    overflow: hidden;
    margin: 0 0.5rem;
  }

  .bar-fill {
    height: 100%;
    background: var(--accent-secondary, #4ecdc4);
    border-radius: 3px;
  }

  .bar-fill.accent {
    background: var(--accent-primary, #ff6b35);
  }

  .subsection-title {
    font-size: 0.85rem;
    margin-top: 1.25rem;
    margin-bottom: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .trend-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .trend-item {
    text-align: center;
    padding: 0.75rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .trend-value {
    display: block;
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--accent-secondary, #4ecdc4);
  }

  .trend-label {
    display: block;
    font-size: 0.7rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.25rem;
  }

  .category-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 1rem;
  }

  .category-item {
    text-align: center;
    padding: 1rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .category-count {
    display: block;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent-primary, #ff6b35);
  }

  .category-label {
    display: block;
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.25rem;
  }

  .facts-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .fact-item {
    display: flex;
    gap: 1rem;
    padding: 0.75rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .fact-icon {
    font-size: 1.5rem;
  }

  .fact-content strong {
    display: block;
    color: var(--text-primary, #fff);
    margin-bottom: 0.25rem;
  }

  .fact-content p {
    font-size: 0.85rem;
    color: var(--text-secondary, #ccc);
    margin: 0;
  }

  .fact-content a {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: none;
  }

  .fact-content a:hover {
    text-decoration: underline;
  }

  .recent-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .recent-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .recent-item:last-child {
    border-bottom: none;
  }

  .recent-item a {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: none;
  }

  .recent-item a:hover {
    text-decoration: underline;
  }

  .recent-item .date {
    font-size: 0.8rem;
    color: var(--text-secondary, #888);
  }

  .more-items {
    margin-top: 0.75rem;
  }

  .more-items summary {
    cursor: pointer;
    color: var(--accent-secondary, #4ecdc4);
    font-size: 0.85rem;
  }

  .more-items summary:hover {
    text-decoration: underline;
  }

  .more-items .popularity-list {
    margin-top: 0.5rem;
  }

  @media (max-width: 768px) {
    .stats-grid {
      grid-template-columns: 1fr;
    }

    .stat-row {
      grid-template-columns: repeat(2, 1fr);
    }

    .trend-stats {
      grid-template-columns: 1fr;
    }
  }

  .stats-footer {
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color, #2a2a35);
    text-align: center;
  }

  .stats-footer p {
    font-size: 0.75rem;
    color: var(--text-secondary, #666);
  }

  .stats-footer a {
    color: var(--text-secondary, #888);
    text-decoration: none;
  }

  .stats-footer a:hover {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: underline;
  }

  /* Heatmap Styles */
  .heatmap-container {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .heatmap-y-label {
    writing-mode: vertical-rl;
    text-orientation: mixed;
    transform: rotate(180deg);
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
  }

  .heatmap-wrapper {
    flex: 1;
    overflow-x: auto;
  }

  .heatmap-grid {
    display: grid;
    gap: 2px;
    min-width: 500px;
  }

  .heatmap-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    min-height: 2rem;
    padding: 0.25rem;
  }

  .heatmap-cell.header {
    color: var(--text-secondary, #888);
    font-weight: 600;
    font-size: 0.7rem;
  }

  .heatmap-cell.row-label {
    color: var(--text-secondary, #888);
    font-weight: 600;
    font-size: 0.7rem;
    justify-content: flex-end;
    padding-right: 0.5rem;
  }

  .heatmap-cell.data {
    background: var(--bg-secondary, #12121a);
    border-radius: 3px;
    color: var(--text-primary, #fff);
    font-weight: 600;
    cursor: default;
    transition: transform 0.1s;
  }

  .heatmap-cell.data:hover {
    transform: scale(1.1);
    z-index: 1;
  }

  .heatmap-x-label {
    text-align: center;
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.5rem;
  }

  .heatmap-legend {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
  }

  .legend-gradient {
    width: 1rem;
    height: 6rem;
    background: linear-gradient(to bottom, rgba(78, 205, 196, 1), rgba(78, 205, 196, 0.2));
    border-radius: 3px;
  }

  .legend-label {
    font-size: 0.65rem;
    color: var(--text-secondary, #888);
  }

  /* Binds Styles */
  .binds-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .bind-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.35rem 0;
  }

  .bind-keys {
    min-width: 100px;
    font-family: monospace;
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--accent-secondary, #4ecdc4);
    letter-spacing: 0.05em;
  }

  /* Crosshair Styles */
  .crosshair-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 1rem;
  }

  .crosshair-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .crosshair-preview {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #1a1a24;
    border-radius: 4px;
    border: 1px solid var(--border-color, #2a2a35);
  }

  .ch {
    position: relative;
  }

  /* Cross (+) */
  .ch-cross::before,
  .ch-cross::after {
    content: '';
    position: absolute;
    background: #4ecdc4;
  }
  .ch-cross::before {
    width: 2px;
    height: 16px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  .ch-cross::after {
    width: 16px;
    height: 2px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  /* Thick Cross */
  .ch-cross-thick::before,
  .ch-cross-thick::after {
    content: '';
    position: absolute;
    background: #4ecdc4;
  }
  .ch-cross-thick::before {
    width: 4px;
    height: 20px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  .ch-cross-thick::after {
    width: 20px;
    height: 4px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  /* Cross with Gap */
  .ch-cross-gap {
    width: 24px;
    height: 24px;
  }
  .ch-cross-gap::before {
    content: '';
    position: absolute;
    width: 2px;
    height: 8px;
    background: #4ecdc4;
    left: 50%;
    transform: translateX(-50%);
    top: 0;
    box-shadow: 0 16px 0 #4ecdc4;
  }
  .ch-cross-gap::after {
    content: '';
    position: absolute;
    width: 8px;
    height: 2px;
    background: #4ecdc4;
    top: 50%;
    transform: translateY(-50%);
    left: 0;
    box-shadow: 16px 0 0 #4ecdc4;
  }

  /* Dot */
  .ch-dot {
    width: 4px;
    height: 4px;
    background: #4ecdc4;
    border-radius: 50%;
  }

  .ch-dot-large {
    width: 8px;
    height: 8px;
    background: #4ecdc4;
    border-radius: 50%;
  }

  /* Circle */
  .ch-circle {
    width: 16px;
    height: 16px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
  }

  /* Circle with Dot */
  .ch-circle-dot {
    width: 16px;
    height: 16px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
    position: relative;
  }
  .ch-circle-dot::after {
    content: '';
    position: absolute;
    width: 4px;
    height: 4px;
    background: #4ecdc4;
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  /* Circle Crosshair */
  .ch-circle-crosshair {
    width: 20px;
    height: 20px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
    position: relative;
  }
  .ch-circle-crosshair::before,
  .ch-circle-crosshair::after {
    content: '';
    position: absolute;
    background: #4ecdc4;
  }
  .ch-circle-crosshair::before {
    width: 2px;
    height: 8px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  .ch-circle-crosshair::after {
    width: 8px;
    height: 2px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  /* X Mark */
  .ch-x {
    width: 16px;
    height: 16px;
    position: relative;
  }
  .ch-x::before,
  .ch-x::after {
    content: '';
    position: absolute;
    width: 2px;
    height: 20px;
    background: #4ecdc4;
    left: 50%;
    top: 50%;
  }
  .ch-x::before {
    transform: translate(-50%, -50%) rotate(45deg);
  }
  .ch-x::after {
    transform: translate(-50%, -50%) rotate(-45deg);
  }

  /* Triangle */
  .ch-triangle {
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-bottom: 14px solid #4ecdc4;
  }

  /* Chevron */
  .ch-chevron {
    width: 16px;
    height: 16px;
    position: relative;
  }
  .ch-chevron::before,
  .ch-chevron::after {
    content: '';
    position: absolute;
    width: 2px;
    height: 12px;
    background: #4ecdc4;
    bottom: 0;
  }
  .ch-chevron::before {
    left: 2px;
    transform: rotate(-30deg);
  }
  .ch-chevron::after {
    right: 2px;
    transform: rotate(30deg);
  }

  /* Unknown */
  .ch-unknown {
    color: var(--text-secondary, #888);
    font-size: 1.25rem;
  }

  .crosshair-info {
    text-align: center;
  }

  .crosshair-type {
    display: block;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-primary, #fff);
  }

  .crosshair-count {
    display: block;
    font-size: 0.7rem;
    color: var(--text-secondary, #888);
  }

  @media (max-width: 600px) {
    .heatmap-container {
      flex-direction: column;
    }

    .heatmap-y-label {
      writing-mode: horizontal-tb;
      transform: none;
    }

    .crosshair-grid {
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    }
  }
</style>
