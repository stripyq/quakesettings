---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import { getBaseModelName } from '../../utils/mousepadGrouping';
import { execSync } from 'child_process';

const players = await getCollection('players');
const mice = await getCollection('mice');
const monitors = await getCollection('monitors');
const keyboards = await getCollection('keyboards');
const mousepads = await getCollection('mousepads');

// Create lookup maps
const miceMap = new Map(mice.map(m => [m.id, m.data]));
const monitorsMap = new Map(monitors.map(m => [m.id, m.data]));
const keyboardsMap = new Map(keyboards.map(k => [k.id, k.data]));
const mousepadsMap = new Map(mousepads.map(p => [p.id, p.data]));

// Calculate cm/360 for a player
function calculateCm360(playerData: any): number {
  if (playerData.cm360) return playerData.cm360;
  if (playerData.m_cpi) {
    return Math.round((360 * playerData.m_cpi / (playerData.sensitivity * playerData.dpi)) * 100) / 100;
  }
  return Math.round((41563.6 / (playerData.dpi * playerData.sensitivity)) * 100) / 100;
}

// ===========================================
// SENSITIVITY STATS
// ===========================================

const cm360Values = players.map(p => calculateCm360(p.data)).sort((a, b) => a - b);
const avgCm360 = cm360Values.length > 0
  ? Math.round((cm360Values.reduce((a, b) => a + b, 0) / cm360Values.length) * 100) / 100
  : 0;
const medianCm360 = cm360Values.length > 0
  ? cm360Values[Math.floor(cm360Values.length / 2)]
  : 0;
const minCm360 = cm360Values.length > 0 ? Math.min(...cm360Values) : 0;
const maxCm360 = cm360Values.length > 0 ? Math.max(...cm360Values) : 0;

// cm/360 distribution buckets with accel player breakdown
const cm360BucketDefs = [
  { label: 'Very High Sens', range: '< 15 cm', min: 0, max: 15 },
  { label: 'High Sens', range: '15\u201320 cm', min: 15, max: 20 },
  { label: 'Medium-High Sens', range: '20\u201325 cm', min: 20, max: 25 },
  { label: 'Medium Sens', range: '25\u201330 cm', min: 25, max: 30 },
  { label: 'Medium-Low Sens', range: '30\u201335 cm', min: 30, max: 35 },
  { label: 'Low Sens', range: '35\u201345 cm', min: 35, max: 45 },
  { label: 'Very Low Sens', range: '45\u201355 cm', min: 45, max: 55 },
  { label: 'Extremely Low Sens', range: '> 55 cm', min: 55, max: Infinity },
];

const playerCm360Data = players.map(p => ({
  cm360: calculateCm360(p.data),
  hasAccel: !!p.data.acceleration,
}));

const cm360Buckets = cm360BucketDefs.map(def => {
  const inRange = playerCm360Data.filter(d => d.cm360 >= def.min && d.cm360 < def.max);
  return {
    ...def,
    total: inRange.length,
    accel: inRange.filter(d => d.hasAccel).length,
  };
});
const maxBucketTotal = Math.max(...cm360Buckets.map(b => b.total), 1);

// ===========================================
// cm/360 vs MOUSEPAD TYPE HEATMAP
// ===========================================

function getSpeedCategory(speed: string): string | null {
  const s = speed.toLowerCase();
  if (['extremely fast', 'very fast', 'fast', 'quick', 'speed'].includes(s)) return 'Speed';
  if (['balanced'].includes(s)) return 'Balanced';
  if (['control', 'slow', 'very slow', 'extremely slow'].includes(s)) return 'Control';
  return null;
}

const padTypes = ['Speed', 'Balanced', 'Control'] as const;

// Build heatmap counts
const padHeatmap = new Map<string, number>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    if (pad?.speed) {
      const category = getSpeedCategory(pad.speed);
      if (category) {
        const cm360 = calculateCm360(p.data);
        const bucket = cm360BucketDefs.find(b => cm360 >= b.min && cm360 < b.max);
        if (bucket) {
          const key = `${bucket.label}|${category}`;
          padHeatmap.set(key, (padHeatmap.get(key) || 0) + 1);
        }
      }
    }
  }
});

// Neutral heatmap scale for cm/360 vs pad type
const neutralHeatColors = ['#21262d', '#2d333b', '#3d444d', '#4d555e', '#5d656f', '#6e7681'];
const padHeatmapMax = Math.max(...padHeatmap.values(), 1);

function getNeutralHeatColor(count: number, max: number): string {
  if (count === 0) return neutralHeatColors[0];
  const ratio = count / max;
  const index = Math.min(Math.floor(ratio * 5) + 1, 5);
  return neutralHeatColors[index];
}

const padHeatmapRows = cm360BucketDefs.map(bucket => ({
  label: bucket.label,
  range: bucket.range,
  cells: padTypes.map(type => {
    const count = padHeatmap.get(`${bucket.label}|${type}`) || 0;
    return { type, count, bg: getNeutralHeatColor(count, padHeatmapMax) };
  }),
}));

const totalPadTypePlayers = [...padHeatmap.values()].reduce((a, b) => a + b, 0);

// ===========================================
// HARDWARE STATS
// ===========================================

// Mouse brand popularity
const mouseBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    const mouseData = miceMap.get(p.data.mouse);
    const brand = mouseData?.brand || 'Unknown';
    mouseBrands.set(brand, (mouseBrands.get(brand) || 0) + 1);
  }
});
const topMouseBrands = [...mouseBrands.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalMouseBrandPlayers = [...mouseBrands.values()].reduce((a, b) => a + b, 0);
const maxMouseBrandCount = topMouseBrands.length > 0 ? topMouseBrands[0][1] : 1;

// Mice (specific models)
const mouseUsage = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    mouseUsage.set(p.data.mouse, (mouseUsage.get(p.data.mouse) || 0) + 1);
  }
});
const topMice = [...mouseUsage.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([id, count]) => ({
    name: miceMap.get(id)?.name || id,
    count,
    percentage: Math.round((count / players.length) * 100)
  }));
const maxMiceCount = topMice.length > 0 ? topMice[0].count : 1;

// Mousepad models (grouped by base model name)
const mousepadModels = new Map<string, { count: number; brand: string }>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    if (pad) {
      const baseModel = getBaseModelName(pad.name);
      const existing = mousepadModels.get(baseModel);
      if (existing) {
        existing.count++;
      } else {
        mousepadModels.set(baseModel, { count: 1, brand: pad.brand });
      }
    }
  }
});
const topMousepads = [...mousepadModels.entries()]
  .sort((a, b) => b[1].count - a[1].count)
  .slice(0, 10)
  .map(([name, data]) => ({
    name,
    count: data.count,
    percentage: Math.round((data.count / players.length) * 100)
  }));
const maxMousepadCount = topMousepads.length > 0 ? topMousepads[0].count : 1;

// Grip style distribution
const gripStyles = new Map<string, number>();
players.forEach(p => {
  if (p.data.grip) {
    gripStyles.set(p.data.grip, (gripStyles.get(p.data.grip) || 0) + 1);
  }
});
const gripDistribution = [...gripStyles.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalGripPlayers = [...gripStyles.values()].reduce((a, b) => a + b, 0);
const maxGripCount = gripDistribution.length > 0 ? gripDistribution[0][1] : 1;

// Mouse shape distribution
const mouseShapeDistribution = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    const mouseData = miceMap.get(p.data.mouse);
    if (mouseData) {
      const shape = mouseData.shape || 'Unknown';
      mouseShapeDistribution.set(shape, (mouseShapeDistribution.get(shape) || 0) + 1);
    }
  }
});
const topMouseShapes = [...mouseShapeDistribution.entries()]
  .sort((a, b) => b[1] - a[1]);
const maxShapeCount = topMouseShapes.length > 0 ? topMouseShapes[0][1] : 1;

// GPU Brand distribution
const gpuBrands = new Map<string, number>();
players.forEach(p => {
  const brand = p.data.gpuBrand || p.data.gpu;
  if (brand) {
    const normalizedBrand = brand.toUpperCase();
    gpuBrands.set(normalizedBrand, (gpuBrands.get(normalizedBrand) || 0) + 1);
  }
});
const topGpuBrands = [...gpuBrands.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalGpuPlayers = [...gpuBrands.values()].reduce((a, b) => a + b, 0);
const maxGpuCount = topGpuBrands.length > 0 ? topGpuBrands[0][1] : 1;

// CPU Brand distribution
const cpuBrands = new Map<string, number>();
players.forEach(p => {
  const brand = p.data.cpuBrand || p.data.cpu;
  if (brand) {
    const normalizedBrand = brand.charAt(0).toUpperCase() + brand.slice(1).toLowerCase();
    cpuBrands.set(normalizedBrand, (cpuBrands.get(normalizedBrand) || 0) + 1);
  }
});
const topCpuBrands = [...cpuBrands.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalCpuPlayers = [...cpuBrands.values()].reduce((a, b) => a + b, 0);
const maxCpuCount = topCpuBrands.length > 0 ? topCpuBrands[0][1] : 1;

// ===========================================
// MONITOR SIZE VS REFRESH RATE HEATMAP
// ===========================================

function parseMonitorSize(size: string): number | null {
  const match = size.match(/(\d+(?:\.\d+)?)/);
  return match ? parseFloat(match[1]) : null;
}

function parseRefreshRate(rate: string): number | null {
  const match = rate.match(/(\d+)/);
  return match ? parseInt(match[1]) : null;
}

const sizeBins = [18, 21, 23, 24, 25, 27, 28, 32, 34];
const refreshBins = [60, 120, 144, 165, 180, 240, 280, 360, 500];

const monitorHeatmap: Map<string, number> = new Map();
players.forEach(p => {
  if (p.data.monitor) {
    const monitorData = monitorsMap.get(p.data.monitor);
    if (monitorData) {
      const size = parseMonitorSize(monitorData.size || '');
      const refresh = parseRefreshRate(monitorData.refreshRate || '');
      if (size !== null && refresh !== null) {
        const sizeBin = sizeBins.reduce((prev, curr) =>
          Math.abs(curr - size) < Math.abs(prev - size) ? curr : prev
        );
        const refreshBin = refreshBins.reduce((prev, curr) =>
          Math.abs(curr - refresh) < Math.abs(prev - refresh) ? curr : prev
        );
        const key = `${sizeBin}-${refreshBin}`;
        monitorHeatmap.set(key, (monitorHeatmap.get(key) || 0) + 1);
      }
    }
  }
});

const heatmapMax = Math.max(...monitorHeatmap.values(), 1);

function getMonitorHeatColor(count: number, max: number): string {
  if (count === 0) return neutralHeatColors[0];
  const ratio = count / max;
  const index = Math.min(Math.floor(ratio * 5) + 1, 5);
  return neutralHeatColors[index];
}

// ===========================================
// GAME SETTINGS
// ===========================================

// FOV distribution
const fovValues = players.map(p => p.data.fov).filter(v => v);
const avgFov = Math.round(fovValues.reduce((a, b) => a + b, 0) / fovValues.length);
const fovDistribution = new Map<number, number>();
fovValues.forEach(fov => {
  fovDistribution.set(fov, (fovDistribution.get(fov) || 0) + 1);
});
const topFovValues = [...fovDistribution.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);
const maxFovCount = topFovValues.length > 0 ? topFovValues[0][1] : 1;

// Acceleration users
const accelUsers = players.filter(p => p.data.acceleration).length;
const accelPercentage = Math.round((accelUsers / players.length) * 100);

// Crosshair color distribution
const crosshairColors = new Map<string, number>();
players.forEach(p => {
  if (p.data.crosshairColor) {
    crosshairColors.set(p.data.crosshairColor, (crosshairColors.get(p.data.crosshairColor) || 0) + 1);
  }
});
const topCrosshairColors = [...crosshairColors.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalCrosshairColorPlayers = [...crosshairColors.values()].reduce((a, b) => a + b, 0);
const maxCrosshairColorCount = topCrosshairColors.length > 0 ? topCrosshairColors[0][1] : 1;

// Crosshair color to bar color mapping (muted versions)
const crosshairColorMap: Record<string, { bg: string; border?: string }> = {
  'Green': { bg: '#238636' },
  'Yellow': { bg: '#9e6a03' },
  'Cyan': { bg: '#1f6feb' },
  'Red': { bg: '#da3633' },
  'White': { bg: '#6e7681' },
  'Magenta': { bg: '#8957e5' },
  'Black': { bg: '#21262d', border: '1px solid #484f58' },
  'Orange': { bg: '#bd5600' },
  'Blue': { bg: '#1f6feb' },
  'Pink': { bg: '#8957e5' },
};

// Crosshair style distribution
const crosshairTypes = new Map<string, number>();
players.forEach(p => {
  const ch = p.data.crosshair || 'Unknown';
  crosshairTypes.set(ch, (crosshairTypes.get(ch) || 0) + 1);
});

const crosshairVisuals: Record<string, string> = {
  '1': 'Circle with dot',
  '2': 'Cross (+)',
  '3': 'Cross with gap',
  '4': 'Small dot',
  '5': 'Large dot',
  '6': 'Dot',
  '7': 'Thick cross',
  '8': 'Circle',
  '9': 'Cross with gap',
  '10': 'X shape',
  '11': 'Triangle',
  '12': 'Chevron',
  '13': 'Circle crosshair',
};

const crosshairStyleData = [...crosshairTypes.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8)
  .map(([type, count]) => ({
    type,
    count,
    percentage: Math.round((count / players.length) * 100),
    description: crosshairVisuals[type] || `Type ${type}`,
  }));
const maxCrosshairStyleCount = crosshairStyleData.length > 0 ? crosshairStyleData[0].count : 1;

// Enemy model distribution
const enemyModels = new Map<string, number>();
players.forEach(p => {
  if (p.data.enemyModel) {
    enemyModels.set(p.data.enemyModel, (enemyModels.get(p.data.enemyModel) || 0) + 1);
  }
});
const topEnemyModels = [...enemyModels.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalEnemyModelPlayers = [...enemyModels.values()].reduce((a, b) => a + b, 0);
const maxEnemyModelCount = topEnemyModels.length > 0 ? topEnemyModels[0][1] : 1;

// ===========================================
// KEY BINDINGS STATISTICS
// ===========================================

const movementPatterns = new Map<string, number>();
const jumpKeys = new Map<string, number>();

players.forEach(p => {
  const forward = (p.data.forward || 'W').toUpperCase();
  const left = (p.data.left || 'A').toUpperCase();
  const back = (p.data.back || 'S').toUpperCase();
  const right = (p.data.right || 'D').toUpperCase();

  let pattern = `${forward}${left}${back}${right}`;
  if (pattern === 'WASD') pattern = 'WASD';
  else if (pattern === 'ESDF') pattern = 'ESDF';
  else if (pattern === 'RFDG') pattern = 'RFDG';
  else if (forward.includes('ARROW') || forward.includes('UP')) pattern = 'Arrow Keys';
  else if (forward.includes('KP_') || forward.includes('NUMPAD')) pattern = 'Numpad';

  movementPatterns.set(pattern, (movementPatterns.get(pattern) || 0) + 1);

  let jump = (p.data.jump || 'Space');
  if (jump.toLowerCase() === 'space' || jump.toLowerCase() === 'spacebar') jump = 'Space';
  else if (jump.toLowerCase().includes('mouse2') || jump.toLowerCase() === 'mwheeldown' || jump.toLowerCase() === 'm2') jump = 'Mouse2';
  else if (jump.toLowerCase().includes('mwheel')) jump = 'Mwheel';
  else if (jump.toLowerCase().includes('mouse')) jump = 'Mouse Button';
  else if (jump.toLowerCase() === 'shift') jump = 'Shift';
  else if (jump.toLowerCase() === 'ctrl' || jump.toLowerCase() === 'control') jump = 'Ctrl';

  jumpKeys.set(jump, (jumpKeys.get(jump) || 0) + 1);
});

const topMovementPatterns = [...movementPatterns.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 6);
const maxMovementCount = topMovementPatterns.length > 0 ? topMovementPatterns[0][1] : 1;
const topJumpKeys = [...jumpKeys.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 6);
const maxJumpCount = topJumpKeys.length > 0 ? topJumpKeys[0][1] : 1;

// ===========================================
// PLAYER STATS
// ===========================================

// Recently updated
function getGitLastModified(filePath: string): string | null {
  try {
    return execSync(`git log -1 --format=%aI -- "${filePath}"`, { encoding: 'utf-8' }).trim() || null;
  } catch { return null; }
}

const playersWithDates = players
  .filter(p => p.data.lastUpdated)
  .map(p => ({
    player: p,
    gitDate: getGitLastModified(`src/content/players/${p.id}.yaml`),
  }));

playersWithDates.sort((a, b) => {
  const luCmp = (b.player.data.lastUpdated || '').localeCompare(a.player.data.lastUpdated || '');
  if (luCmp !== 0) return luCmp;
  return (b.gitDate || '').localeCompare(a.gitDate || '');
});

const recentPlayers = playersWithDates.slice(0, 5).map(p => ({
  ...p.player,
  gitDate: p.gitDate ? p.gitDate.slice(0, 10) : p.player.data.lastUpdated,
}));

// ===========================================
// INTERESTING FACTS
// ===========================================

const lowestSensPlayer = players.reduce((prev, curr) =>
  calculateCm360(curr.data) > calculateCm360(prev.data) ? curr : prev
);
const highestSensPlayer = players.reduce((prev, curr) =>
  calculateCm360(curr.data) < calculateCm360(prev.data) ? curr : prev
);

// Highest and lowest FOV
const playersWithFov = players.filter(p => p.data.fov);
const highestFovPlayer = playersWithFov.length > 0
  ? playersWithFov.reduce((prev, curr) => curr.data.fov > prev.data.fov ? curr : prev)
  : null;
const lowestFovPlayer = playersWithFov.length > 0
  ? playersWithFov.reduce((prev, curr) => curr.data.fov < prev.data.fov ? curr : prev)
  : null;

// Format cm/360 values
function formatCm360(value: number): string {
  const fixed = value.toFixed(2);
  return fixed.endsWith('.00') ? Math.round(value).toString() : fixed;
}

// Summary card: most popular mouse
const topMouseName = topMice.length > 0 ? topMice[0].name : 'N/A';

// Format bind strings
function formatBindString(bind: string): string {
  return bind.replace(/^(MOUSE[12])([A-Z])/, '$1 $2');
}

const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;
---

<BaseLayout title="Statistics">
  <div class="stats-page">
    <div class="page-header">
      <h1>Player Statistics</h1>
      <p>Aggregated data from {players.length} Quake Live players</p>
    </div>

    <!-- ========== SUMMARY CARDS ========== -->
    <div class="s-summary-cards">
      <div class="s-summary-card">
        <span class="s-summary-value">{players.length}</span>
        <span class="s-summary-label">Total Players</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{formatCm360(avgCm360)}</span>
        <span class="s-summary-label">Avg cm/360</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{accelPercentage}%</span>
        <span class="s-summary-label">Accel Users</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value s-summary-value-sm">{topMouseName}</span>
        <span class="s-summary-label">Top Mouse</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{avgFov}&deg;</span>
        <span class="s-summary-label">Avg FOV</span>
      </div>
    </div>

    <!-- ========== SECTION 1: HARDWARE ========== -->
    <div class="s-section-header" style="--section-color: #238636">
      <div class="s-section-icon" style="background: #238636">&#128433;&#65039;</div>
      <span class="s-section-title" style="color: #238636">HARDWARE</span>
    </div>

    <div class="s-two-col">
      <!-- Top Mouse Brands -->
      <div class="s-card">
        <h2 class="s-card-title">Top Mouse Brands</h2>
        <div class="s-bar-list">
          {topMouseBrands.map(([brand, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{brand}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxMouseBrandCount) * 100}%; background: #238636`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / totalMouseBrandPlayers) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- Top Mice -->
      <div class="s-card">
        <h2 class="s-card-title">Top Mice</h2>
        <div class="s-bar-list">
          {topMice.slice(0, 8).map((mouse) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{mouse.name}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(mouse.count / maxMiceCount) * 100}%; background: #238636`}>
                  <span class="s-bar-count">{mouse.count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{mouse.percentage}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <div class="s-two-col">
      <!-- Top Mousepads -->
      <div class="s-card">
        <h2 class="s-card-title">Top Mousepads</h2>
        <p class="s-card-sub">Grouped by model (all sizes)</p>
        <div class="s-bar-list">
          {topMousepads.slice(0, 8).map((pad) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{pad.name}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(pad.count / maxMousepadCount) * 100}%; background: #238636`}>
                  <span class="s-bar-count">{pad.count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{pad.percentage}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- Grip Style -->
      <div class="s-card">
        <h2 class="s-card-title">Grip Style</h2>
        <p class="s-card-sub">{totalGripPlayers} players with data</p>
        <div class="s-bar-list">
          {gripDistribution.map(([style, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{style}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxGripCount) * 100}%; background: #238636`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / totalGripPlayers) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <div class="s-two-col">
      <!-- Mouse Shape -->
      <div class="s-card">
        <h2 class="s-card-title">Mouse Shape</h2>
        <div class="s-bar-list">
          {topMouseShapes.map(([shape, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{shape}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxShapeCount) * 100}%; background: #238636`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- GPU / CPU Brand -->
      <div class="s-card">
        <h2 class="s-card-title">GPU / CPU Brand</h2>
        <h3 class="s-subsection-title">GPU ({totalGpuPlayers} players)</h3>
        <div class="s-bar-list s-bar-list-compact">
          {topGpuBrands.map(([brand, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{brand}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxGpuCount) * 100}%; background: #238636`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / totalGpuPlayers) * 100)}%</span>
            </div>
          ))}
        </div>
        <h3 class="s-subsection-title">CPU ({totalCpuPlayers} players)</h3>
        <div class="s-bar-list s-bar-list-compact">
          {topCpuBrands.map(([brand, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{brand}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxCpuCount) * 100}%; background: #238636`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / totalCpuPlayers) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- Monitor Size vs Refresh Rate Heatmap (full width) -->
    <div class="s-card s-card-wide">
      <h2 class="s-card-title">Monitor Size vs Refresh Rate</h2>
      <div class="s-heatmap-scroll">
        <div class="s-heatmap-grid" style={`grid-template-columns: auto repeat(${refreshBins.length}, 70px)`}>
          <div class="s-heatmap-cell s-hm-corner"></div>
          {refreshBins.map(rate => (
            <div class="s-heatmap-cell s-hm-header">{rate}Hz</div>
          ))}
          {[...sizeBins].reverse().map(size => (
            <>
              <div class="s-heatmap-cell s-hm-rowlabel">{size}"</div>
              {refreshBins.map(rate => {
                const count = monitorHeatmap.get(`${size}-${rate}`) || 0;
                return (
                  <div
                    class="s-heatmap-cell s-hm-data"
                    style={`background-color: ${getMonitorHeatColor(count, heatmapMax)}`}
                    title={`${size}" @ ${rate}Hz: ${count} players`}
                  >
                    {count > 0 ? count : ''}
                  </div>
                );
              })}
            </>
          ))}
        </div>
      </div>
      <div class="s-heatmap-legend">
        <span class="s-heatmap-legend-label">0</span>
        <div class="s-heatmap-legend-bar">
          {neutralHeatColors.map(c => (
            <div class="s-heatmap-legend-swatch" style={`background: ${c}`}></div>
          ))}
        </div>
        <span class="s-heatmap-legend-label">Max</span>
      </div>
    </div>

    <!-- ========== SECTION 2: SENSITIVITY ========== -->
    <div class="s-section-header" style="--section-color: #1f6feb">
      <div class="s-section-icon" style="background: #1f6feb">&#127919;</div>
      <span class="s-section-title" style="color: #1f6feb">SENSITIVITY</span>
    </div>

    <div class="s-two-col">
      <!-- cm/360 Distribution -->
      <div class="s-card">
        <h2 class="s-card-title">cm/360 Distribution</h2>
        <div class="s-cm360-legend">
          <span class="s-cm360-legend-item"><span class="s-cm360-swatch" style="background: #1f6feb"></span> All players</span>
          <span class="s-cm360-legend-item"><span class="s-cm360-swatch" style="background: #58a6ff"></span> Accel players</span>
        </div>
        <div class="s-cm360-chart">
          {cm360Buckets.map(bucket => (
            <div class="s-cm360-row">
              <div class="s-cm360-label">
                <span class="s-cm360-name">{bucket.label}</span>
                <span class="s-cm360-range">{bucket.range}</span>
              </div>
              <div class="s-cm360-bars">
                <div class="s-cm360-track">
                  {bucket.total > 0 && (
                    <div class="s-cm360-fill" style={`width: ${(bucket.total / maxBucketTotal) * 100}%; background: #1f6feb`}>
                      <span class="s-cm360-fill-count">{bucket.total}</span>
                    </div>
                  )}
                </div>
                {bucket.accel > 0 && (
                  <div class="s-cm360-track s-cm360-track-sm">
                    <div class="s-cm360-fill" style={`width: ${(bucket.accel / maxBucketTotal) * 100}%; background: #58a6ff`}>
                      <span class="s-cm360-fill-count">{bucket.accel}</span>
                    </div>
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
        <div class="s-cm360-summary">
          <span><strong>Average:</strong> {formatCm360(avgCm360)}</span>
          <span><strong>Median:</strong> {formatCm360(medianCm360)}</span>
          <span><strong>Min/Max:</strong> {formatCm360(minCm360)} / {formatCm360(maxCm360)}</span>
        </div>
        <p class="s-cm360-note"><em>Note:</em> For accel players, cm/360 represents base (slowest) sensitivity</p>
      </div>

      <!-- cm/360 vs Mousepad Type -->
      <div class="s-card">
        <h2 class="s-card-title">cm/360 vs Mousepad Type</h2>
        <p class="s-card-sub">{totalPadTypePlayers} players with mousepad speed data</p>
        <div class="s-pad-heatmap-grid">
          <div class="s-pad-corner"></div>
          <div class="s-pad-colheader">Speed</div>
          <div class="s-pad-colheader">Balanced</div>
          <div class="s-pad-colheader">Control</div>
          {padHeatmapRows.map(row => (
            <>
              <div class="s-pad-rowlabel">
                <span class="s-pad-rowlabel-name">{row.label}</span>
                <span class="s-pad-rowlabel-range">{row.range}</span>
              </div>
              {row.cells.map(cell => (
                <div
                  class="s-pad-cell"
                  style={`background-color: ${cell.bg}`}
                  title={`${row.label} + ${cell.type}: ${cell.count} players`}
                >
                  {cell.count > 0 ? cell.count : ''}
                </div>
              ))}
            </>
          ))}
        </div>
        <div class="s-heatmap-legend">
          <span class="s-heatmap-legend-label">0</span>
          <div class="s-heatmap-legend-bar">
            {neutralHeatColors.map(c => (
              <div class="s-heatmap-legend-swatch" style={`background: ${c}`}></div>
            ))}
          </div>
          <span class="s-heatmap-legend-label">Max</span>
        </div>
      </div>
    </div>

    <!-- ========== SECTION 3: GAME SETTINGS ========== -->
    <div class="s-section-header" style="--section-color: #8957e5">
      <div class="s-section-icon" style="background: #8957e5">&#9881;&#65039;</div>
      <span class="s-section-title" style="color: #8957e5">GAME SETTINGS</span>
    </div>

    <div class="s-three-col">
      <!-- FOV Distribution -->
      <div class="s-card">
        <h2 class="s-card-title">FOV Distribution</h2>
        <p class="s-card-sub">Average FOV: {avgFov}&deg;</p>
        <div class="s-bar-list">
          {topFovValues.map(([fov, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{fov}&deg;</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxFovCount) * 100}%; background: #8957e5`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- Crosshair Color (special: bars ARE the color) -->
      <div class="s-card">
        <h2 class="s-card-title">Crosshair Color</h2>
        <p class="s-card-sub">{totalCrosshairColorPlayers} players with data</p>
        <div class="s-bar-list">
          {topCrosshairColors.map(([color, count]) => {
            const colorStyle = crosshairColorMap[color] || { bg: '#8957e5' };
            return (
              <div class="s-bar-row">
                <span class="s-bar-label">{color}</span>
                <div class="s-bar-container">
                  <div
                    class="s-bar"
                    style={`width: ${(count / maxCrosshairColorCount) * 100}%; background: ${colorStyle.bg}; ${colorStyle.border ? `border: ${colorStyle.border}` : ''}`}
                  >
                    <span class="s-bar-count">{count}</span>
                  </div>
                </div>
                <span class="s-bar-pct">{Math.round((count / totalCrosshairColorPlayers) * 100)}%</span>
              </div>
            );
          })}
        </div>
      </div>

      <!-- Crosshair Style -->
      <div class="s-card">
        <h2 class="s-card-title">Crosshair Style</h2>
        <p class="s-card-sub">cg_drawCrosshair values</p>
        <div class="s-bar-list">
          {crosshairStyleData.map(({ type, count, percentage, description }) => (
            <div class="s-bar-row">
              <span class="s-bar-label" title={description}>Type {type}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxCrosshairStyleCount) * 100}%; background: #8957e5`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{percentage}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- Enemy Model (single row below) -->
    <div class="s-two-col">
      <div class="s-card">
        <h2 class="s-card-title">Enemy Model</h2>
        <p class="s-card-sub">{totalEnemyModelPlayers} players with data</p>
        <div class="s-bar-list">
          {topEnemyModels.map(([model, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label">{model}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxEnemyModelCount) * 100}%; background: #8957e5`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / totalEnemyModelPlayers) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>
      <div>{/* spacer for layout */}</div>
    </div>

    <!-- ========== SECTION 4: CONTROLS ========== -->
    <div class="s-section-header" style="--section-color: #da3633">
      <div class="s-section-icon" style="background: #da3633">&#9000;&#65039;</div>
      <span class="s-section-title" style="color: #da3633">CONTROLS</span>
    </div>

    <div class="s-two-col">
      <!-- Movement Keys -->
      <div class="s-card">
        <h2 class="s-card-title">Movement Keys</h2>
        <div class="s-bar-list">
          {topMovementPatterns.map(([pattern, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label s-bar-label-mono">{formatBindString(pattern)}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxMovementCount) * 100}%; background: #da3633`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- Jump Key -->
      <div class="s-card">
        <h2 class="s-card-title">Jump Key</h2>
        <div class="s-bar-list">
          {topJumpKeys.map(([key, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label s-bar-label-mono">{key}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxJumpCount) * 100}%; background: #da3633`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- ========== SECTION 5: PLAYERS ========== -->
    <div class="s-section-header" style="--section-color: #d29922">
      <div class="s-section-icon" style="background: #d29922">&#128101;</div>
      <span class="s-section-title" style="color: #d29922">PLAYERS</span>
    </div>

    <div class="s-two-col">
      <!-- Recently Updated -->
      {recentPlayers.length > 0 && (
        <div class="s-card">
          <h2 class="s-card-title">Recently Updated</h2>
          <div class="s-recent-list">
            {recentPlayers.map((p, i) => (
              <div class="s-recent-item">
                <span class="s-recent-rank">{i + 1}</span>
                <a href={`${base}players/${p.id}/`} class="s-recent-name">{p.data.name}</a>
                {p.data.country && <span class="s-recent-country">{p.data.country}</span>}
                <span class="s-recent-date">{p.gitDate}</span>
              </div>
            ))}
          </div>
        </div>
      )}

      <!-- Interesting Facts -->
      <div class="s-card">
        <h2 class="s-card-title">Interesting Facts</h2>
        <div class="s-facts-grid">
          <div class="s-fact-card">
            <span class="s-fact-label">Highest Sensitivity</span>
            <a href={`${base}players/${highestSensPlayer.id}/`} class="s-fact-value">{highestSensPlayer.data.name}</a>
            <span class="s-fact-detail">{formatCm360(calculateCm360(highestSensPlayer.data))} cm/360</span>
          </div>
          <div class="s-fact-card">
            <span class="s-fact-label">Lowest Sensitivity</span>
            <a href={`${base}players/${lowestSensPlayer.id}/`} class="s-fact-value">{lowestSensPlayer.data.name}</a>
            <span class="s-fact-detail">{formatCm360(calculateCm360(lowestSensPlayer.data))} cm/360</span>
          </div>
          {highestFovPlayer && (
            <div class="s-fact-card">
              <span class="s-fact-label">Highest FOV</span>
              <a href={`${base}players/${highestFovPlayer.id}/`} class="s-fact-value">{highestFovPlayer.data.name}</a>
              <span class="s-fact-detail">{highestFovPlayer.data.fov}&deg;</span>
            </div>
          )}
          {lowestFovPlayer && (
            <div class="s-fact-card">
              <span class="s-fact-label">Lowest FOV</span>
              <a href={`${base}players/${lowestFovPlayer.id}/`} class="s-fact-value">{lowestFovPlayer.data.name}</a>
              <span class="s-fact-detail">{lowestFovPlayer.data.fov}&deg;</span>
            </div>
          )}
        </div>
      </div>
    </div>

    <footer class="s-footer">
      <p>Duel ratings via <a href="https://qlstats.net/ranks/duel/1" target="_blank" rel="noopener">QLStats</a> &bull; CTF/TDM ratings via <a href="http://88.214.20.58/ratings/" target="_blank" rel="noopener">HoQ community tracker</a></p>
    </footer>
  </div>
</BaseLayout>

<style>
  /* ===========================================
     Stats Page - GitHub-Inspired Dark Theme
     =========================================== */

  .stats-page {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    max-width: 1200px;
    margin: 0 auto;
  }

  /* --- Summary Cards --- */
  .s-summary-cards {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 1rem;
  }

  .s-summary-card {
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 8px;
    padding: 16px;
    text-align: center;
  }

  .s-summary-value {
    display: block;
    font-size: 1.75rem;
    font-weight: 600;
    color: #f0f6fc;
    line-height: 1.2;
  }

  .s-summary-value-sm {
    font-size: 0.95rem;
    line-height: 1.8;
  }

  .s-summary-label {
    display: block;
    font-size: 0.8rem;
    color: #8b949e;
    margin-top: 0.35rem;
  }

  /* --- Section Headers --- */
  .s-section-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid #30363d;
    margin-top: 0.5rem;
  }

  .s-section-icon {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    line-height: 1;
  }

  .s-section-title {
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  /* --- Grid Layouts --- */
  .s-two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
  }

  .s-three-col {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 24px;
  }

  /* --- Cards --- */
  .s-card {
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 8px;
    padding: 1.25rem;
  }

  .s-card-wide {
    width: 100%;
  }

  .s-card-title {
    font-size: 0.95rem;
    font-weight: 600;
    color: #f0f6fc;
    margin-bottom: 0.75rem;
  }

  .s-card-sub {
    font-size: 0.8rem;
    color: #8b949e;
    margin-top: -0.5rem;
    margin-bottom: 0.75rem;
  }

  .s-subsection-title {
    font-size: 0.8rem;
    color: #8b949e;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  /* --- Bar Chart Rows --- */
  .s-bar-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .s-bar-list-compact {
    gap: 4px;
  }

  .s-bar-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .s-bar-label {
    width: 100px;
    min-width: 100px;
    text-align: right;
    font-size: 0.8rem;
    color: #8b949e;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .s-bar-label-mono {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    letter-spacing: 0.03em;
  }

  .s-bar-container {
    flex: 1;
    background: #21262d;
    height: 20px;
    border-radius: 4px;
    overflow: hidden;
  }

  .s-bar {
    height: 100%;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 6px;
    min-width: fit-content;
    transition: width 0.3s ease;
  }

  .s-bar-count {
    font-size: 0.7rem;
    font-weight: 500;
    color: #f0f6fc;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  }

  .s-bar-pct {
    width: 40px;
    min-width: 40px;
    text-align: right;
    font-size: 0.75rem;
    color: #8b949e;
  }

  /* --- cm/360 Distribution --- */
  .s-cm360-legend {
    display: flex;
    gap: 1.25rem;
    margin-bottom: 0.75rem;
  }

  .s-cm360-legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.75rem;
    color: #8b949e;
  }

  .s-cm360-swatch {
    width: 10px;
    height: 10px;
    border-radius: 2px;
    display: inline-block;
  }

  .s-cm360-chart {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .s-cm360-row {
    display: flex;
    align-items: flex-start;
    gap: 8px;
  }

  .s-cm360-label {
    width: 120px;
    min-width: 120px;
    text-align: right;
    display: flex;
    flex-direction: column;
  }

  .s-cm360-name {
    font-size: 0.75rem;
    color: #c9d1d9;
    line-height: 1.2;
  }

  .s-cm360-range {
    font-size: 0.65rem;
    color: #484f58;
  }

  .s-cm360-bars {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .s-cm360-track {
    height: 20px;
    background: #21262d;
    border-radius: 4px;
    overflow: hidden;
  }

  .s-cm360-track-sm {
    height: 10px;
    border-radius: 3px;
  }

  .s-cm360-fill {
    height: 100%;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 4px;
    min-width: fit-content;
  }

  .s-cm360-fill-count {
    font-size: 0.65rem;
    font-weight: 500;
    color: #f0f6fc;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  }

  .s-cm360-track-sm .s-cm360-fill-count {
    font-size: 0.55rem;
  }

  .s-cm360-summary {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px solid #30363d;
    font-size: 0.8rem;
    color: #c9d1d9;
  }

  .s-cm360-note {
    margin-top: 0.5rem;
    font-size: 0.75rem;
    color: #8b949e;
  }

  .s-cm360-note em {
    color: #c9d1d9;
    font-style: normal;
    font-weight: 600;
  }

  /* --- Heatmaps (shared) --- */
  .s-heatmap-scroll {
    overflow-x: auto;
  }

  .s-heatmap-grid {
    display: grid;
    gap: 2px;
    min-width: 500px;
  }

  .s-heatmap-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 500;
    color: #f0f6fc;
    min-height: 28px;
  }

  .s-hm-corner {
    /* empty */
  }

  .s-hm-header {
    color: #8b949e;
    font-size: 0.65rem;
    font-weight: 600;
  }

  .s-hm-rowlabel {
    color: #8b949e;
    font-size: 0.7rem;
    font-weight: 600;
    justify-content: flex-end;
    padding-right: 8px;
  }

  .s-hm-data {
    border-radius: 3px;
    cursor: default;
    transition: transform 0.1s;
  }

  .s-hm-data:hover {
    transform: scale(1.08);
    z-index: 1;
  }

  .s-heatmap-legend {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    margin-top: 0.75rem;
  }

  .s-heatmap-legend-label {
    font-size: 0.65rem;
    color: #8b949e;
  }

  .s-heatmap-legend-bar {
    display: flex;
    gap: 2px;
  }

  .s-heatmap-legend-swatch {
    width: 20px;
    height: 10px;
    border-radius: 2px;
  }

  /* --- cm/360 vs Pad Type Heatmap --- */
  .s-pad-heatmap-grid {
    display: grid;
    grid-template-columns: 120px repeat(3, 1fr);
    gap: 4px;
  }

  .s-pad-corner {
    /* empty */
  }

  .s-pad-colheader {
    text-align: center;
    font-size: 0.8rem;
    font-weight: 600;
    color: #c9d1d9;
    padding: 0.4rem 0;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .s-pad-rowlabel {
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: right;
    padding-right: 0.5rem;
  }

  .s-pad-rowlabel-name {
    font-size: 0.7rem;
    color: #c9d1d9;
    line-height: 1.2;
  }

  .s-pad-rowlabel-range {
    font-size: 0.6rem;
    color: #484f58;
  }

  .s-pad-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 28px;
    border-radius: 3px;
    font-size: 0.8rem;
    font-weight: 500;
    color: #f0f6fc;
    cursor: default;
    transition: transform 0.1s;
  }

  .s-pad-cell:hover {
    transform: scale(1.05);
    z-index: 1;
  }

  /* --- Recently Updated --- */
  .s-recent-list {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .s-recent-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: #21262d;
    border-radius: 6px;
    margin-bottom: 6px;
  }

  .s-recent-item:last-child {
    margin-bottom: 0;
  }

  .s-recent-rank {
    font-size: 0.8rem;
    font-weight: 600;
    color: #484f58;
    min-width: 1.5rem;
  }

  .s-recent-name {
    flex: 1;
    color: var(--link-internal, #4ecdc4);
    text-decoration: none;
    font-weight: 500;
  }

  .s-recent-name:hover {
    text-decoration: underline;
  }

  .s-recent-country {
    font-size: 0.75rem;
    color: #8b949e;
  }

  .s-recent-date {
    font-size: 0.75rem;
    color: #8b949e;
  }

  /* --- Interesting Facts --- */
  .s-facts-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .s-fact-card {
    background: #21262d;
    border-radius: 6px;
    border-left: 3px solid #30363d;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .s-fact-label {
    font-size: 0.7rem;
    color: #8b949e;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .s-fact-value {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--link-internal, #4ecdc4);
    text-decoration: none;
  }

  .s-fact-value:hover {
    text-decoration: underline;
  }

  .s-fact-detail {
    font-size: 0.8rem;
    color: #c9d1d9;
  }

  /* --- Footer --- */
  .s-footer {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid #30363d;
    text-align: center;
  }

  .s-footer p {
    font-size: 0.75rem;
    color: #484f58;
  }

  .s-footer a {
    color: #8b949e;
    text-decoration: none;
  }

  .s-footer a:hover {
    color: #c9d1d9;
    text-decoration: underline;
  }

  /* ===========================================
     Responsive
     =========================================== */

  /* Tablet */
  @media (max-width: 1024px) {
    .s-three-col {
      grid-template-columns: 1fr 1fr;
    }
  }

  /* Mobile */
  @media (max-width: 768px) {
    .s-summary-cards {
      grid-template-columns: repeat(3, 1fr);
    }

    .s-two-col {
      grid-template-columns: 1fr;
    }

    .s-three-col {
      grid-template-columns: 1fr;
    }

    .s-bar-label {
      width: 80px;
      min-width: 80px;
      font-size: 0.75rem;
    }

    .s-card {
      padding: 1rem;
    }

    .s-cm360-label {
      width: 90px;
      min-width: 90px;
    }

    .s-pad-heatmap-grid {
      grid-template-columns: 90px repeat(3, 1fr);
    }

    .s-heatmap-grid .s-hm-data,
    .s-pad-cell {
      min-height: 24px;
      font-size: 0.7rem;
    }

    .s-facts-grid {
      grid-template-columns: 1fr;
    }

    .s-cm360-summary {
      flex-direction: column;
      gap: 0.25rem;
    }
  }

  @media (max-width: 480px) {
    .s-summary-cards {
      grid-template-columns: repeat(2, 1fr);
    }

    .s-summary-value {
      font-size: 1.35rem;
    }

    .s-bar-label {
      width: 70px;
      min-width: 70px;
    }

    .s-cm360-label {
      width: 75px;
      min-width: 75px;
    }

    .s-cm360-name {
      font-size: 0.65rem;
    }

    .s-pad-heatmap-grid {
      grid-template-columns: 75px repeat(3, 1fr);
    }

    .s-pad-rowlabel-name {
      font-size: 0.6rem;
    }
  }
</style>
