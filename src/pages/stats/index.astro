---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import { getBaseModelName } from '../../utils/mousepadGrouping';
import { execSync } from 'child_process';

const players = await getCollection('players');
const mice = await getCollection('mice');
const monitors = await getCollection('monitors');
const keyboards = await getCollection('keyboards');
const mousepads = await getCollection('mousepads');

// Create lookup maps
const miceMap = new Map(mice.map(m => [m.id, m.data]));
const monitorsMap = new Map(monitors.map(m => [m.id, m.data]));
const keyboardsMap = new Map(keyboards.map(k => [k.id, k.data]));
const mousepadsMap = new Map(mousepads.map(p => [p.id, p.data]));

// Calculate cm/360 for a player
function calculateCm360(playerData: any): number {
  if (playerData.cm360) return playerData.cm360;
  if (playerData.m_cpi) {
    // When m_cpi is set: cm360 = 360 √ó m_cpi / (sensitivity √ó DPI)
    // When m_cpi = DPI, this simplifies to 360 / sensitivity
    return Math.round((360 * playerData.m_cpi / (playerData.sensitivity * playerData.dpi)) * 100) / 100;
  }
  return Math.round((41563.6 / (playerData.dpi * playerData.sensitivity)) * 100) / 100;
}

// ===========================================
// SENSITIVITY STATS
// ===========================================

// cm/360 calculations (includes all players - cm/360 is base sensitivity, accel is applied on top)
const cm360Values = players.map(p => calculateCm360(p.data)).sort((a, b) => a - b);
const avgCm360 = cm360Values.length > 0
  ? Math.round((cm360Values.reduce((a, b) => a + b, 0) / cm360Values.length) * 100) / 100
  : 0;
const medianCm360 = cm360Values.length > 0
  ? cm360Values[Math.floor(cm360Values.length / 2)]
  : 0;
const minCm360 = cm360Values.length > 0 ? Math.min(...cm360Values) : 0;
const maxCm360 = cm360Values.length > 0 ? Math.max(...cm360Values) : 0;

// eDPI stats
const edpiValues = players.map(p => p.data.edpi).filter(v => v).sort((a, b) => a - b);
const avgEdpi = Math.round(edpiValues.reduce((a, b) => a + b, 0) / edpiValues.length);
const medianEdpi = edpiValues.length > 0 ? edpiValues[Math.floor(edpiValues.length / 2)] : 0;
const minEdpi = Math.min(...edpiValues);
const maxEdpi = Math.max(...edpiValues);

// DPI distribution
const dpiValues = players.map(p => p.data.dpi).filter(v => v);
const avgDpi = Math.round(dpiValues.reduce((a, b) => a + b, 0) / dpiValues.length);
const dpiDistribution = new Map<number, number>();
dpiValues.forEach(dpi => {
  // Round to common DPI values
  const rounded = [400, 800, 1600, 3200].reduce((prev, curr) =>
    Math.abs(curr - dpi) < Math.abs(prev - dpi) ? curr : prev
  );
  dpiDistribution.set(rounded, (dpiDistribution.get(rounded) || 0) + 1);
});
const topDpiValues = [...dpiDistribution.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 4);

// cm/360 distribution buckets with accel player breakdown
const cm360BucketDefs = [
  { label: 'Very High Sens', range: '< 15 cm', min: 0, max: 15 },
  { label: 'High Sens', range: '15\u201320 cm', min: 15, max: 20 },
  { label: 'Medium-High Sens', range: '20\u201325 cm', min: 20, max: 25 },
  { label: 'Medium Sens', range: '25\u201330 cm', min: 25, max: 30 },
  { label: 'Medium-Low Sens', range: '30\u201335 cm', min: 30, max: 35 },
  { label: 'Low Sens', range: '35\u201345 cm', min: 35, max: 45 },
  { label: 'Very Low Sens', range: '45\u201355 cm', min: 45, max: 55 },
  { label: 'Extremely Low Sens', range: '> 55 cm', min: 55, max: Infinity },
];

const playerCm360Data = players.map(p => ({
  cm360: calculateCm360(p.data),
  hasAccel: !!p.data.acceleration,
}));

const cm360Buckets = cm360BucketDefs.map(def => {
  const inRange = playerCm360Data.filter(d => d.cm360 >= def.min && d.cm360 < def.max);
  return {
    ...def,
    total: inRange.length,
    accel: inRange.filter(d => d.hasAccel).length,
  };
});
const maxBucketTotal = Math.max(...cm360Buckets.map(b => b.total), 1);

// ===========================================
// cm/360 vs MOUSEPAD TYPE HEATMAP
// ===========================================

function getSpeedCategory(speed: string): string | null {
  const s = speed.toLowerCase();
  if (['extremely fast', 'very fast', 'fast', 'quick', 'speed'].includes(s)) return 'Speed';
  if (['balanced'].includes(s)) return 'Balanced';
  if (['control', 'slow', 'very slow', 'extremely slow'].includes(s)) return 'Control';
  return null;
}

const padTypes = ['Speed', 'Balanced', 'Control'] as const;
const padTypeRgb: Record<string, string> = {
  Speed: '255, 107, 53',
  Balanced: '168, 85, 247',
  Control: '0, 180, 216',
};

// Build heatmap counts
const padHeatmap = new Map<string, number>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    if (pad?.speed) {
      const category = getSpeedCategory(pad.speed);
      if (category) {
        const cm360 = calculateCm360(p.data);
        const bucket = cm360BucketDefs.find(b => cm360 >= b.min && cm360 < b.max);
        if (bucket) {
          const key = `${bucket.label}|${category}`;
          padHeatmap.set(key, (padHeatmap.get(key) || 0) + 1);
        }
      }
    }
  }
});

// Per-column max for independent color scaling
const padTypeMaxes: Record<string, number> = { Speed: 1, Balanced: 1, Control: 1 };
padHeatmap.forEach((count, key) => {
  const type = key.split('|')[1];
  if (count > padTypeMaxes[type]) padTypeMaxes[type] = count;
});

// Pre-compute heatmap rows with style strings
const padHeatmapRows = cm360BucketDefs.map(bucket => ({
  label: bucket.label,
  range: bucket.range,
  cells: padTypes.map(type => {
    const count = padHeatmap.get(`${bucket.label}|${type}`) || 0;
    const max = padTypeMaxes[type];
    const intensity = count > 0 ? 0.25 + (count / max) * 0.75 : 0;
    const bg = count > 0
      ? `rgba(${padTypeRgb[type]}, ${intensity.toFixed(2)})`
      : '#1a1a2e';
    return { type, count, bg };
  }),
}));

// Total players with mousepad type data
const totalPadTypePlayers = [...padHeatmap.values()].reduce((a, b) => a + b, 0);

// Mice
const mouseUsage = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    mouseUsage.set(p.data.mouse, (mouseUsage.get(p.data.mouse) || 0) + 1);
  }
});
const topMice = [...mouseUsage.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([id, count]) => ({
    name: miceMap.get(id)?.name || id,
    count,
    percentage: Math.round((count / players.length) * 100)
  }));

// Mouse brand popularity
const mouseBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    const mouseData = miceMap.get(p.data.mouse);
    const brand = mouseData?.brand || 'Unknown';
    mouseBrands.set(brand, (mouseBrands.get(brand) || 0) + 1);
  }
});
const topMouseBrands = [...mouseBrands.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalMouseBrandPlayers = [...mouseBrands.values()].reduce((a, b) => a + b, 0);

// Monitors by refresh rate
const monitorRefreshRates = new Map<string, number>();
players.forEach(p => {
  if (p.data.monitor) {
    const monitor = monitorsMap.get(p.data.monitor);
    const refreshRate = monitor?.refreshRate || 'Unknown';
    monitorRefreshRates.set(refreshRate, (monitorRefreshRates.get(refreshRate) || 0) + 1);
  }
});
const topRefreshRates = [...monitorRefreshRates.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Keyboard brands
const keyboardBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.keyboard) {
    const kb = keyboardsMap.get(p.data.keyboard);
    const brand = kb?.brand || 'Unknown';
    keyboardBrands.set(brand, (keyboardBrands.get(brand) || 0) + 1);
  }
});
const topKeyboardBrands = [...keyboardBrands.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Mousepad brands
const mousepadBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    const brand = pad?.brand || 'Unknown';
    mousepadBrands.set(brand, (mousepadBrands.get(brand) || 0) + 1);
  }
});
const topMousepadBrands = [...mousepadBrands.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Mousepad models (grouped by base model name)
const mousepadModels = new Map<string, { count: number; brand: string }>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    if (pad) {
      const baseModel = getBaseModelName(pad.name);
      const existing = mousepadModels.get(baseModel);
      if (existing) {
        existing.count++;
      } else {
        mousepadModels.set(baseModel, { count: 1, brand: pad.brand });
      }
    }
  }
});
const topMousepads = [...mousepadModels.entries()]
  .sort((a, b) => b[1].count - a[1].count)
  .slice(0, 10)
  .map(([name, data]) => ({
    name,
    count: data.count,
    percentage: Math.round((data.count / players.length) * 100)
  }));

// GPU Brand distribution (check both gpuBrand and gpu fields)
const gpuBrands = new Map<string, number>();
players.forEach(p => {
  const brand = p.data.gpuBrand || p.data.gpu;
  if (brand) {
    // Normalize to uppercase for consistency
    const normalizedBrand = brand.toUpperCase();
    gpuBrands.set(normalizedBrand, (gpuBrands.get(normalizedBrand) || 0) + 1);
  }
});
const topGpuBrands = [...gpuBrands.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalGpuPlayers = [...gpuBrands.values()].reduce((a, b) => a + b, 0);

// CPU Brand distribution (check both cpuBrand and cpu fields)
const cpuBrands = new Map<string, number>();
players.forEach(p => {
  const brand = p.data.cpuBrand || p.data.cpu;
  if (brand) {
    // Normalize: capitalize first letter
    const normalizedBrand = brand.charAt(0).toUpperCase() + brand.slice(1).toLowerCase();
    cpuBrands.set(normalizedBrand, (cpuBrands.get(normalizedBrand) || 0) + 1);
  }
});
const topCpuBrands = [...cpuBrands.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalCpuPlayers = [...cpuBrands.values()].reduce((a, b) => a + b, 0);

// ===========================================
// SETTINGS TRENDS
// ===========================================

// FOV distribution
const fovValues = players.map(p => p.data.fov).filter(v => v);
const avgFov = Math.round(fovValues.reduce((a, b) => a + b, 0) / fovValues.length);
const fovDistribution = new Map<number, number>();
fovValues.forEach(fov => {
  fovDistribution.set(fov, (fovDistribution.get(fov) || 0) + 1);
});
const topFovValues = [...fovDistribution.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Acceleration users
const accelUsers = players.filter(p => p.data.acceleration).length;
const accelPercentage = Math.round((accelUsers / players.length) * 100);

// m_cpi users
const mcpiUsers = players.filter(p => p.data.m_cpi).length;
const mcpiPercentage = Math.round((mcpiUsers / players.length) * 100);

// Crosshair types
const crosshairTypes = new Map<string, number>();
players.forEach(p => {
  const ch = p.data.crosshair || 'Unknown';
  crosshairTypes.set(ch, (crosshairTypes.get(ch) || 0) + 1);
});
const topCrosshairs = [...crosshairTypes.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

// Grip style distribution
const gripStyles = new Map<string, number>();
players.forEach(p => {
  if (p.data.grip) {
    gripStyles.set(p.data.grip, (gripStyles.get(p.data.grip) || 0) + 1);
  }
});
const gripDistribution = [...gripStyles.entries()]
  .sort((a, b) => b[1] - a[1]);
const totalGripPlayers = [...gripStyles.values()].reduce((a, b) => a + b, 0);

// Crosshair color distribution
const crosshairColors = new Map<string, number>();
players.forEach(p => {
  if (p.data.crosshairColor) {
    crosshairColors.set(p.data.crosshairColor, (crosshairColors.get(p.data.crosshairColor) || 0) + 1);
  }
});
const topCrosshairColors = [...crosshairColors.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalCrosshairColorPlayers = [...crosshairColors.values()].reduce((a, b) => a + b, 0);

// Enemy model distribution
const enemyModels = new Map<string, number>();
players.forEach(p => {
  if (p.data.enemyModel) {
    enemyModels.set(p.data.enemyModel, (enemyModels.get(p.data.enemyModel) || 0) + 1);
  }
});
const topEnemyModels = [...enemyModels.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalEnemyModelPlayers = [...enemyModels.values()].reduce((a, b) => a + b, 0);

// ===========================================
// PLAYER STATS
// ===========================================

// Categories
const categoryDuel = players.filter(p => p.data.category === 'duel').length;
const categoryCTF = players.filter(p => p.data.category === 'ctf').length;
const categoryTDM = players.filter(p => p.data.category === 'tdm').length;
const categoryOther = players.length - categoryDuel - categoryCTF - categoryTDM;

// Recently updated: rank by lastUpdated (intentional signal), use git date for precise display
function getGitLastModified(filePath: string): string | null {
  try {
    return execSync(`git log -1 --format=%aI -- "${filePath}"`, { encoding: 'utf-8' }).trim() || null;
  } catch { return null; }
}

const playersWithDates = players
  .filter(p => p.data.lastUpdated)
  .map(p => ({
    player: p,
    gitDate: getGitLastModified(`src/content/players/${p.id}.yaml`),
  }));

// Primary sort by lastUpdated (month bucket), tiebreak by git timestamp
playersWithDates.sort((a, b) => {
  const luCmp = (b.player.data.lastUpdated || '').localeCompare(a.player.data.lastUpdated || '');
  if (luCmp !== 0) return luCmp;
  return (b.gitDate || '').localeCompare(a.gitDate || '');
});

const recentPlayers = playersWithDates.slice(0, 5).map(p => ({
  ...p.player,
  gitDate: p.gitDate ? p.gitDate.slice(0, 10) : p.player.data.lastUpdated,
}));

// ===========================================
// INTERESTING FACTS
// ===========================================

// Lowest sens player (highest cm/360)
const lowestSensPlayer = players.reduce((prev, curr) =>
  calculateCm360(curr.data) > calculateCm360(prev.data) ? curr : prev
);

// Highest sens player (lowest cm/360)
const highestSensPlayer = players.reduce((prev, curr) =>
  calculateCm360(curr.data) < calculateCm360(prev.data) ? curr : prev
);

// ===========================================
// MOUSE SHAPE & SIZE STATISTICS
// ===========================================

// Mouse shape distribution
const mouseShapeDistribution = new Map<string, number>();
const mouseWeightDistribution = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    const mouseData = miceMap.get(p.data.mouse);
    if (mouseData) {
      // Shape
      const shape = mouseData.shape || 'Unknown';
      mouseShapeDistribution.set(shape, (mouseShapeDistribution.get(shape) || 0) + 1);

      // Weight (categorize)
      if (mouseData.weight && mouseData.weight !== 'Unknown') {
        const weightNum = parseFloat(mouseData.weight);
        let weightCategory = 'Unknown';
        if (weightNum < 70) weightCategory = 'Ultralight (<70g)';
        else if (weightNum < 90) weightCategory = 'Light (70-89g)';
        else if (weightNum < 110) weightCategory = 'Medium (90-109g)';
        else weightCategory = 'Heavy (110g+)';
        mouseWeightDistribution.set(weightCategory, (mouseWeightDistribution.get(weightCategory) || 0) + 1);
      }
    }
  }
});

const topMouseShapes = [...mouseShapeDistribution.entries()]
  .sort((a, b) => b[1] - a[1]);
const topMouseWeights = [...mouseWeightDistribution.entries()]
  .sort((a, b) => {
    // Sort by weight category order
    const order = ['Ultralight (<70g)', 'Light (70-89g)', 'Medium (90-109g)', 'Heavy (110g+)', 'Unknown'];
    return order.indexOf(a[0]) - order.indexOf(b[0]);
  });

// ===========================================
// MONITOR SIZE VS REFRESH RATE HEATMAP
// ===========================================

// Parse size to number (e.g., "27 inch" or "27\"" -> 27)
function parseMonitorSize(size: string): number | null {
  const match = size.match(/(\d+(?:\.\d+)?)/);
  return match ? parseFloat(match[1]) : null;
}

// Parse refresh rate to number (e.g., "360Hz" -> 360)
function parseRefreshRate(rate: string): number | null {
  const match = rate.match(/(\d+)/);
  return match ? parseInt(match[1]) : null;
}

// Define bins for the heatmap
const sizeBins = [18, 21, 23, 24, 25, 27, 28, 32, 34];
const refreshBins = [60, 120, 144, 165, 180, 240, 280, 360, 500];

// Build heatmap data
const monitorHeatmap: Map<string, number> = new Map();
players.forEach(p => {
  if (p.data.monitor) {
    const monitorData = monitorsMap.get(p.data.monitor);
    if (monitorData) {
      const size = parseMonitorSize(monitorData.size || '');
      const refresh = parseRefreshRate(monitorData.refreshRate || '');

      if (size !== null && refresh !== null) {
        // Find closest size bin
        const sizeBin = sizeBins.reduce((prev, curr) =>
          Math.abs(curr - size) < Math.abs(prev - size) ? curr : prev
        );
        // Find closest refresh bin
        const refreshBin = refreshBins.reduce((prev, curr) =>
          Math.abs(curr - refresh) < Math.abs(prev - refresh) ? curr : prev
        );

        const key = `${sizeBin}-${refreshBin}`;
        monitorHeatmap.set(key, (monitorHeatmap.get(key) || 0) + 1);
      }
    }
  }
});

// Calculate max for color scaling
const heatmapMax = Math.max(...monitorHeatmap.values(), 1);

// ===========================================
// KEY BINDINGS STATISTICS
// ===========================================

// Movement keys analysis
const movementPatterns = new Map<string, number>();
const jumpKeys = new Map<string, number>();

players.forEach(p => {
  // Analyze movement pattern
  const forward = (p.data.forward || 'W').toUpperCase();
  const left = (p.data.left || 'A').toUpperCase();
  const back = (p.data.back || 'S').toUpperCase();
  const right = (p.data.right || 'D').toUpperCase();

  let pattern = `${forward}${left}${back}${right}`;

  // Normalize common patterns
  if (pattern === 'WASD') pattern = 'WASD';
  else if (pattern === 'ESDF') pattern = 'ESDF';
  else if (pattern === 'RFDG') pattern = 'RFDG';
  else if (forward.includes('ARROW') || forward.includes('UP')) pattern = 'Arrow Keys';
  else if (forward.includes('KP_') || forward.includes('NUMPAD')) pattern = 'Numpad';

  movementPatterns.set(pattern, (movementPatterns.get(pattern) || 0) + 1);

  // Analyze jump key
  let jump = (p.data.jump || 'Space');
  // Normalize
  if (jump.toLowerCase() === 'space' || jump.toLowerCase() === 'spacebar') jump = 'Space';
  else if (jump.toLowerCase().includes('mouse2') || jump.toLowerCase() === 'mwheeldown' || jump.toLowerCase() === 'm2') jump = 'Mouse2';
  else if (jump.toLowerCase().includes('mouse')) jump = 'Mouse Button';
  else if (jump.toLowerCase() === 'shift') jump = 'Shift';
  else if (jump.toLowerCase() === 'ctrl' || jump.toLowerCase() === 'control') jump = 'Ctrl';

  jumpKeys.set(jump, (jumpKeys.get(jump) || 0) + 1);
});

const topMovementPatterns = [...movementPatterns.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const topJumpKeys = [...jumpKeys.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 6);

// Format bind strings to add space after MOUSE1/MOUSE2
function formatBindString(bind: string): string {
  return bind.replace(/^(MOUSE[12])([A-Z])/, '$1 $2');
}

// ===========================================
// CROSSHAIR VISUALIZATION DATA
// ===========================================

// Crosshair type to visual description mapping
const crosshairVisuals: Record<string, { shape: string; description: string }> = {
  '1': { shape: 'circle-dot', description: 'Circle with dot' },
  '2': { shape: 'cross', description: 'Cross (+)' },
  '3': { shape: 'cross-gap', description: 'Cross with gap' },
  '4': { shape: 'dot', description: 'Small dot' },
  '5': { shape: 'dot-large', description: 'Large dot' },
  '6': { shape: 'dot', description: 'Dot' },
  '7': { shape: 'cross-thick', description: 'Thick cross' },
  '8': { shape: 'circle', description: 'Circle' },
  '9': { shape: 'cross-gap', description: 'Cross with gap' },
  '10': { shape: 'x-mark', description: 'X shape' },
  '11': { shape: 'triangle', description: 'Triangle' },
  '12': { shape: 'chevron', description: 'Chevron' },
  '13': { shape: 'circle-crosshair', description: 'Circle crosshair' },
};

// Get crosshair data with counts
const crosshairData = [...crosshairTypes.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 10)
  .map(([type, count]) => ({
    type,
    count,
    percentage: Math.round((count / players.length) * 100),
    visual: crosshairVisuals[type] || { shape: 'unknown', description: `Type ${type}` }
  }));

// Format cm/360 values - remove .00 for whole numbers
function formatCm360(value: number): string {
  const fixed = value.toFixed(2);
  return fixed.endsWith('.00') ? Math.round(value).toString() : fixed;
}

// Summary card: most popular mouse
const topMouseName = topMice.length > 0 ? topMice[0].name : 'N/A';

// Ensure base URL has trailing slash
const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;
---

<BaseLayout title="Statistics">
  <div class="page-header">
    <h1>Player Statistics</h1>
    <p>Aggregated data from {players.length} Quake Live players</p>
  </div>

  <div class="stats-container">
    <!-- ========== SUMMARY CARDS ========== -->
    <div class="summary-cards">
      <div class="summary-card">
        <span class="summary-value">{players.length}</span>
        <span class="summary-label">Total Players</span>
      </div>
      <div class="summary-card">
        <span class="summary-value">{formatCm360(avgCm360)}</span>
        <span class="summary-label">Avg cm/360</span>
      </div>
      <div class="summary-card">
        <span class="summary-value">{formatCm360(medianCm360)}</span>
        <span class="summary-label">Median cm/360</span>
      </div>
      <div class="summary-card">
        <span class="summary-value">{accelPercentage}%</span>
        <span class="summary-label">Use Accel</span>
      </div>
      <div class="summary-card">
        <span class="summary-value summary-value-sm">{topMouseName}</span>
        <span class="summary-label">#1 Mouse</span>
      </div>
    </div>

    <!-- ========== HARDWARE SECTION ========== -->
    <h3 class="section-header">Hardware</h3>

    <div class="two-col">
      <section class="stat-card">
        <h2>Mouse Brands</h2>
        <p class="card-subtitle">{totalMouseBrandPlayers} players with data</p>
        <div class="popularity-list">
          {topMouseBrands.map(([brand, count]) => (
            <div class="popularity-item">
              <span class="name">{brand}</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / totalMouseBrandPlayers) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / totalMouseBrandPlayers) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>

      <section class="stat-card">
        <h2>Mousepad Brands</h2>
        <div class="popularity-list">
          {topMousepadBrands.map(([brand, count]) => (
            <div class="popularity-item">
              <span class="name">{brand}</span>
              <div class="bar-wrapper">
                <div class="bar-fill accent" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / players.length) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <div class="two-col">
      {totalGripPlayers > 0 ? (
        <section class="stat-card">
          <h2>Grip Style</h2>
          <p class="card-subtitle">{totalGripPlayers} players with data</p>
          <div class="popularity-list">
            {gripDistribution.map(([style, count]) => (
              <div class="popularity-item">
                <span class="name">{style}</span>
                <div class="bar-wrapper">
                  <div class="bar-fill accent" style={`width: ${(count / totalGripPlayers) * 100}%`}></div>
                </div>
                <span class="count">{count} ({Math.round((count / totalGripPlayers) * 100)}%)</span>
              </div>
            ))}
          </div>
        </section>
      ) : <section class="stat-card"><h2>Grip Style</h2><p>No data available</p></section>}

      <section class="stat-card">
        <h2>DPI Distribution</h2>
        <p class="card-subtitle">Average DPI: {avgDpi}</p>
        <div class="popularity-list">
          {topDpiValues.map(([dpi, count]) => (
            <div class="popularity-item">
              <span class="name">{dpi} DPI</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / players.length) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <!-- ========== SENSITIVITY SECTION ========== -->
    <h3 class="section-header">Sensitivity</h3>

    <section class="stat-card wide">
      <h2>cm/360 Distribution</h2>
      <p class="card-subtitle">Base sensitivity distribution across all players</p>
      <div class="cm360-legend">
        <span class="cm360-legend-item"><span class="cm360-swatch orange"></span> All players</span>
        <span class="cm360-legend-item"><span class="cm360-swatch cyan"></span> Accel players</span>
      </div>
      <div class="cm360-chart">
        {cm360Buckets.map(bucket => (
          <div class="cm360-row">
            <div class="cm360-label">
              <span class="cm360-label-name">{bucket.label}</span>
              <span class="cm360-label-range">{bucket.range}</span>
            </div>
            <div class="cm360-bars">
              <div class="cm360-bar-track">
                {bucket.total > 0 ? (
                  <div class="cm360-bar-main" style={`width: ${(bucket.total / maxBucketTotal) * 100}%`}></div>
                ) : null}
              </div>
              <div class="cm360-bar-track accel">
                {bucket.accel > 0 ? (
                  <div class="cm360-bar-accel" style={`width: ${(bucket.accel / maxBucketTotal) * 100}%`}></div>
                ) : null}
              </div>
            </div>
            <div class="cm360-stats">{bucket.total} total / {bucket.accel} accel</div>
          </div>
        ))}
      </div>
      <div class="cm360-summary">
        <div class="cm360-summary-item"><strong>Average:</strong> {formatCm360(avgCm360)} cm/360</div>
        <div class="cm360-summary-item"><strong>Median:</strong> {formatCm360(medianCm360)} cm/360</div>
        <div class="cm360-summary-item"><strong>Min / Max:</strong> {formatCm360(minCm360)} / {formatCm360(maxCm360)} cm/360</div>
      </div>
      <p class="cm360-note"><em>Note:</em> For accel players, cm/360 represents their base (slowest) sensitivity. Effective sensitivity varies with mouse speed.</p>
    </section>

    <section class="stat-card wide">
      <h2>cm/360 vs Mousepad Type</h2>
      <p class="card-subtitle">{totalPadTypePlayers} players with mousepad speed data</p>
      <div class="pad-heatmap">
        <div class="pad-heatmap-grid">
          <div class="pad-heatmap-corner"></div>
          <div class="pad-heatmap-col-header speed">Speed</div>
          <div class="pad-heatmap-col-header balanced">Balanced</div>
          <div class="pad-heatmap-col-header control">Control</div>
          {padHeatmapRows.map(row => (
            <>
              <div class="pad-heatmap-label">
                <span class="pad-heatmap-label-name">{row.label}</span>
                <span class="pad-heatmap-label-range">{row.range}</span>
              </div>
              {row.cells.map(cell => (
                <div
                  class="pad-heatmap-cell"
                  style={`background-color: ${cell.bg}`}
                  title={`${row.label} + ${cell.type}: ${cell.count} players`}
                >
                  {cell.count > 0 ? cell.count : ''}
                </div>
              ))}
            </>
          ))}
        </div>
        <div class="pad-heatmap-legend">
          <span class="pad-heatmap-legend-label">Fewer players</span>
          <div class="pad-heatmap-legend-bar">
            <div class="pad-legend-grad speed-grad"></div>
            <div class="pad-legend-grad balanced-grad"></div>
            <div class="pad-legend-grad control-grad"></div>
          </div>
          <span class="pad-heatmap-legend-label">More players</span>
        </div>
      </div>
    </section>

    <!-- ========== GAME SETTINGS SECTION ========== -->
    <h3 class="section-header">Game Settings</h3>

    <div class="three-col">
      <section class="stat-card">
        <h2>FOV Distribution</h2>
        <p class="card-subtitle">Average FOV: {avgFov}</p>
        <div class="popularity-list">
          {topFovValues.map(([fov, count]) => (
            <div class="popularity-item">
              <span class="name">{fov}¬∞</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / players.length) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / players.length) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>

      <section class="stat-card">
        <h2>Crosshair Color</h2>
        <p class="card-subtitle">{totalCrosshairColorPlayers} players with data</p>
        <div class="popularity-list compact">
          {topCrosshairColors.map(([color, count]) => (
            <div class="popularity-item">
              <span class="name">{color}</span>
              <div class="bar-wrapper">
                <div class="bar-fill" style={`width: ${(count / totalCrosshairColorPlayers) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / totalCrosshairColorPlayers) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>

      <section class="stat-card">
        <h2>Enemy Model</h2>
        <p class="card-subtitle">{totalEnemyModelPlayers} players with data</p>
        <div class="popularity-list compact">
          {topEnemyModels.map(([model, count]) => (
            <div class="popularity-item">
              <span class="name">{model}</span>
              <div class="bar-wrapper">
                <div class="bar-fill accent" style={`width: ${(count / totalEnemyModelPlayers) * 100}%`}></div>
              </div>
              <span class="count">{count} ({Math.round((count / totalEnemyModelPlayers) * 100)}%)</span>
            </div>
          ))}
        </div>
      </section>
    </div>

    <!-- ========== PLAYERS SECTION ========== -->
    <h3 class="section-header">Players</h3>

    <div class="three-col">
      <section class="stat-card">
        <h2>Players by Category</h2>
        <div class="category-grid">
          <div class="category-item">
            <span class="category-count">{categoryDuel}</span>
            <span class="category-label">Duel</span>
          </div>
          <div class="category-item">
            <span class="category-count">{categoryCTF}</span>
            <span class="category-label">CTF</span>
          </div>
          <div class="category-item">
            <span class="category-count">{categoryTDM}</span>
            <span class="category-label">TDM</span>
          </div>
          {categoryOther > 0 && (
            <div class="category-item">
              <span class="category-count">{categoryOther}</span>
              <span class="category-label">Other</span>
            </div>
          )}
        </div>
      </section>

      {recentPlayers.length > 0 && (
        <section class="stat-card">
          <h2>Recently Updated</h2>
          <div class="recent-list">
            {recentPlayers.map(p => (
              <div class="recent-item">
                <a href={`${base}players/${p.id}/`}>{p.data.name}</a>
                <span class="date">{p.gitDate}</span>
              </div>
            ))}
          </div>
        </section>
      )}

      <section class="stat-card highlight">
        <h2>Interesting Facts</h2>
        <div class="facts-list">
          <div class="fact-item">
            <span class="fact-icon">üê¢</span>
            <div class="fact-content">
              <strong>Lowest Sensitivity</strong>
              <p>
                <a href={`${base}players/${lowestSensPlayer.id}/`}>{lowestSensPlayer.data.name}</a>
                uses {formatCm360(calculateCm360(lowestSensPlayer.data))} cm/360
              </p>
            </div>
          </div>
          <div class="fact-item">
            <span class="fact-icon">‚ö°</span>
            <div class="fact-content">
              <strong>Highest Sensitivity</strong>
              <p>
                <a href={`${base}players/${highestSensPlayer.id}/`}>{highestSensPlayer.data.name}</a>
                uses {formatCm360(calculateCm360(highestSensPlayer.data))} cm/360
              </p>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <footer class="stats-footer">
    <p>Duel ratings via <a href="https://qlstats.net/ranks/duel/1" target="_blank" rel="noopener">QLStats</a> ‚Ä¢ CTF/TDM ratings via <a href="http://88.214.20.58/ratings/" target="_blank" rel="noopener">HoQ community tracker</a></p>
  </footer>
</BaseLayout>

<style>
  .stats-container {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* Summary Cards */
  .summary-cards {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 1rem;
  }

  .summary-card {
    background: var(--bg-card, #1a1a24);
    border: 1px solid var(--border-color, #2a2a35);
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
    border-top: 3px solid var(--accent-primary, #ff6b35);
  }

  .summary-value {
    display: block;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent-primary, #ff6b35);
    line-height: 1.2;
  }

  .summary-value-sm {
    font-size: 0.95rem;
  }

  .summary-label {
    display: block;
    font-size: 0.7rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-top: 0.35rem;
  }

  @media (max-width: 700px) {
    .summary-cards {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  @media (max-width: 450px) {
    .summary-cards {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  /* 55/45 two-column layout */
  .two-col-55-45 {
    display: grid;
    grid-template-columns: 55fr 45fr;
    gap: 1.5rem;
  }

  @media (max-width: 700px) {
    .two-col-55-45 {
      grid-template-columns: 1fr;
    }
  }

  .section-header {
    font-size: 0.9rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin: 1rem 0 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .two-col {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }

  .three-col {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1.5rem;
  }

  @media (max-width: 900px) {
    .three-col {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 700px) {
    .two-col,
    .three-col {
      grid-template-columns: 1fr;
    }
  }

  .stat-card {
    background: var(--bg-card, #1a1a24);
    border-radius: 8px;
    padding: 1.5rem;
    border: 1px solid var(--border-color, #2a2a35);
  }

  .stat-card.wide {
    width: 100%;
  }

  .stat-card.highlight {
    border-color: var(--accent-primary, #ff6b35);
    background: linear-gradient(135deg, var(--bg-card, #1a1a24) 0%, rgba(255, 107, 53, 0.05) 100%);
  }

  .stat-card h2 {
    font-size: 1rem;
    margin-bottom: 1rem;
    color: var(--accent-primary, #ff6b35);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .card-subtitle {
    font-size: 0.8rem;
    color: var(--text-secondary, #888);
    margin-top: -0.75rem;
    margin-bottom: 1rem;
  }

  .stat-row {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .big-stat {
    text-align: center;
    padding: 1rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .stat-number {
    display: block;
    font-size: 1.75rem;
    font-weight: 700;
    color: var(--accent-secondary, #4ecdc4);
  }

  .stat-label {
    display: block;
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.25rem;
  }

  .stat-details {
    font-size: 0.85rem;
    color: var(--text-secondary, #ccc);
  }

  .stat-details div {
    margin-bottom: 0.25rem;
  }

  .stat-note {
    font-size: 0.75rem;
    color: var(--text-secondary, #666);
    margin-top: 0.75rem;
    font-style: italic;
  }

  .sensitivity-info {
    margin-top: 1.25rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color, #2a2a35);
    font-size: 0.85rem;
    color: var(--text-secondary, #a0a0b0);
  }

  .sensitivity-info p {
    margin: 0 0 0.5rem 0;
  }

  .disclaimer-note {
    margin-top: 0.75rem;
    line-height: 1.4;
  }

  .disclaimer-note em {
    color: var(--accent-primary, #ff6b35);
  }

  /* cm/360 Distribution Chart */
  .cm360-legend {
    display: flex;
    gap: 1.5rem;
    margin-bottom: 1rem;
  }

  .cm360-legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: var(--text-secondary, #aaa);
  }

  .cm360-swatch {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    display: inline-block;
  }

  .cm360-swatch.orange {
    background: linear-gradient(90deg, #ff6b35, #ff8c42);
  }

  .cm360-swatch.cyan {
    background: linear-gradient(90deg, #00b4d8, #00d9ff);
  }

  .cm360-chart {
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .cm360-row {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
  }

  .cm360-label {
    width: 160px;
    min-width: 160px;
    text-align: right;
    display: flex;
    flex-direction: column;
    padding-top: 2px;
  }

  .cm360-label-name {
    font-size: 0.8rem;
    color: #aaa;
    line-height: 1.2;
  }

  .cm360-label-range {
    font-size: 0.7rem;
    color: #666;
  }

  .cm360-bars {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 3px;
  }

  .cm360-bar-track {
    height: 24px;
    background: #0f0f23;
    border-radius: 4px;
    overflow: hidden;
  }

  .cm360-bar-track.accel {
    height: 12px;
    border-radius: 3px;
  }

  .cm360-bar-main {
    height: 100%;
    background: linear-gradient(90deg, #ff6b35, #ff8c42);
    border-radius: 4px;
    transition: width 0.3s ease;
  }

  .cm360-bar-accel {
    height: 100%;
    background: linear-gradient(90deg, #00b4d8, #00d9ff);
    border-radius: 3px;
    transition: width 0.3s ease;
  }

  .cm360-stats {
    width: 120px;
    min-width: 120px;
    font-size: 0.75rem;
    color: #888;
    padding-top: 3px;
    white-space: nowrap;
  }

  .cm360-summary {
    display: flex;
    gap: 2rem;
    margin-top: 1.25rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color, #2a2a35);
    font-size: 0.85rem;
    color: var(--text-secondary, #aaa);
    flex-wrap: wrap;
  }

  .cm360-note {
    margin-top: 0.75rem;
    font-size: 0.8rem;
    color: var(--text-secondary, #666);
  }

  .cm360-note em {
    color: var(--accent-primary, #ff6b35);
  }

  @media (max-width: 700px) {
    .cm360-label {
      width: 100px;
      min-width: 100px;
    }

    .cm360-stats {
      display: none;
    }

    .cm360-summary {
      flex-direction: column;
      gap: 0.5rem;
    }
  }

  /* cm/360 vs Mousepad Type Heatmap */
  .pad-heatmap-grid {
    display: grid;
    grid-template-columns: 160px repeat(3, 1fr);
    gap: 4px;
  }

  .pad-heatmap-corner {
    /* empty top-left cell */
  }

  .pad-heatmap-col-header {
    text-align: center;
    font-size: 0.85rem;
    font-weight: 700;
    padding: 0.5rem 0;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .pad-heatmap-col-header.speed { color: #ff6b35; }
  .pad-heatmap-col-header.balanced { color: #a855f7; }
  .pad-heatmap-col-header.control { color: #00b4d8; }

  .pad-heatmap-label {
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: right;
    padding-right: 0.75rem;
  }

  .pad-heatmap-label-name {
    font-size: 0.8rem;
    color: #aaa;
    line-height: 1.2;
  }

  .pad-heatmap-label-range {
    font-size: 0.7rem;
    color: #666;
  }

  .pad-heatmap-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 40px;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 700;
    color: var(--text-primary, #fff);
    cursor: default;
    transition: transform 0.1s;
  }

  .pad-heatmap-cell:hover {
    transform: scale(1.05);
    z-index: 1;
  }

  .pad-heatmap-legend {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.75rem;
    margin-top: 1rem;
  }

  .pad-heatmap-legend-label {
    font-size: 0.7rem;
    color: #888;
  }

  .pad-heatmap-legend-bar {
    display: flex;
    gap: 4px;
  }

  .pad-legend-grad {
    width: 80px;
    height: 10px;
    border-radius: 3px;
  }

  .pad-legend-grad.speed-grad {
    background: linear-gradient(90deg, rgba(255, 107, 53, 0.15), rgba(255, 107, 53, 1));
  }

  .pad-legend-grad.balanced-grad {
    background: linear-gradient(90deg, rgba(168, 85, 247, 0.15), rgba(168, 85, 247, 1));
  }

  .pad-legend-grad.control-grad {
    background: linear-gradient(90deg, rgba(0, 180, 216, 0.15), rgba(0, 180, 216, 1));
  }

  @media (max-width: 700px) {
    .pad-heatmap-grid {
      grid-template-columns: 100px repeat(3, 1fr);
    }

    .pad-heatmap-col-header {
      font-size: 0.7rem;
    }

    .pad-heatmap-cell {
      min-height: 32px;
      font-size: 12px;
    }

    .pad-legend-grad {
      width: 50px;
    }
  }

  .popularity-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .popularity-list.compact {
    gap: 0.35rem;
  }

  .popularity-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.35rem 0;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .popularity-item:last-child {
    border-bottom: none;
  }

  .rank {
    font-weight: 700;
    color: var(--accent-primary, #ff6b35);
    min-width: 2rem;
  }

  .name {
    flex: 1;
    font-size: 0.9rem;
  }

  .count {
    font-size: 0.8rem;
    color: var(--text-secondary, #888);
    text-align: right;
  }

  .bar-wrapper {
    flex: 1;
    height: 6px;
    background: var(--bg-secondary, #12121a);
    border-radius: 3px;
    overflow: hidden;
    margin: 0 0.5rem;
  }

  .bar-fill {
    height: 100%;
    background: var(--accent-secondary, #4ecdc4);
    border-radius: 3px;
  }

  .bar-fill.accent {
    background: var(--accent-primary, #ff6b35);
  }

  .subsection-title {
    font-size: 0.85rem;
    margin-top: 1.25rem;
    margin-bottom: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .trend-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .trend-item {
    text-align: center;
    padding: 0.75rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .trend-value {
    display: block;
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--accent-secondary, #4ecdc4);
  }

  .trend-label {
    display: block;
    font-size: 0.7rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.25rem;
  }

  .category-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 1rem;
  }

  .category-item {
    text-align: center;
    padding: 1rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .category-count {
    display: block;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--accent-primary, #ff6b35);
  }

  .category-label {
    display: block;
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.25rem;
  }

  .facts-list {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .fact-item {
    display: flex;
    gap: 1rem;
    padding: 0.75rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .fact-icon {
    font-size: 1.5rem;
  }

  .fact-content strong {
    display: block;
    color: var(--text-primary, #fff);
    margin-bottom: 0.25rem;
  }

  .fact-content p {
    font-size: 0.85rem;
    color: var(--text-secondary, #ccc);
    margin: 0;
  }

  .fact-content a {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: none;
  }

  .fact-content a:hover {
    text-decoration: underline;
  }

  .recent-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .recent-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid var(--border-color, #2a2a35);
  }

  .recent-item:last-child {
    border-bottom: none;
  }

  .recent-item a {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: none;
  }

  .recent-item a:hover {
    text-decoration: underline;
  }

  .recent-item .date {
    font-size: 0.8rem;
    color: var(--text-secondary, #888);
  }

  .more-items {
    margin-top: 0.75rem;
  }

  .more-items summary {
    cursor: pointer;
    color: var(--accent-secondary, #4ecdc4);
    font-size: 0.85rem;
  }

  .more-items summary:hover {
    text-decoration: underline;
  }

  .more-items .popularity-list {
    margin-top: 0.5rem;
  }

  @media (max-width: 768px) {
    .stats-grid {
      grid-template-columns: 1fr;
    }

    .stat-row {
      grid-template-columns: repeat(2, 1fr);
    }

    .trend-stats {
      grid-template-columns: 1fr;
    }
  }

  .stats-footer {
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color, #2a2a35);
    text-align: center;
  }

  .stats-footer p {
    font-size: 0.75rem;
    color: var(--text-secondary, #666);
  }

  .stats-footer a {
    color: var(--text-secondary, #888);
    text-decoration: none;
  }

  .stats-footer a:hover {
    color: var(--accent-secondary, #4ecdc4);
    text-decoration: underline;
  }

  /* Heatmap Styles */
  .heatmap-container {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .heatmap-y-label {
    writing-mode: vertical-rl;
    text-orientation: mixed;
    transform: rotate(180deg);
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
  }

  .heatmap-wrapper {
    flex: 1;
    overflow-x: auto;
  }

  .heatmap-grid {
    display: grid;
    gap: 2px;
    min-width: 500px;
  }

  .heatmap-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    min-height: 2rem;
    padding: 0.25rem;
  }

  .heatmap-cell.header {
    color: var(--text-secondary, #888);
    font-weight: 600;
    font-size: 0.7rem;
  }

  .heatmap-cell.row-label {
    color: var(--text-secondary, #888);
    font-weight: 600;
    font-size: 0.7rem;
    justify-content: flex-end;
    padding-right: 0.5rem;
  }

  .heatmap-cell.data {
    background: var(--bg-secondary, #12121a);
    border-radius: 3px;
    color: var(--text-primary, #fff);
    font-weight: 600;
    cursor: default;
    transition: transform 0.1s;
  }

  .heatmap-cell.data:hover {
    transform: scale(1.1);
    z-index: 1;
  }

  .heatmap-x-label {
    text-align: center;
    font-size: 0.75rem;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    margin-top: 0.5rem;
  }

  .heatmap-legend {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.25rem;
  }

  .legend-gradient {
    width: 1rem;
    height: 6rem;
    background: linear-gradient(to bottom, rgba(78, 205, 196, 1), rgba(78, 205, 196, 0.2));
    border-radius: 3px;
  }

  .legend-label {
    font-size: 0.65rem;
    color: var(--text-secondary, #888);
  }

  /* Binds Styles */
  .binds-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .bind-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.35rem 0;
  }

  .bind-keys {
    min-width: 100px;
    font-family: monospace;
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--accent-secondary, #4ecdc4);
    letter-spacing: 0.05em;
  }

  /* Crosshair Styles */
  .crosshair-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 1rem;
  }

  .crosshair-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--bg-secondary, #12121a);
    border-radius: 6px;
  }

  .crosshair-preview {
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #1a1a24;
    border-radius: 4px;
    border: 1px solid var(--border-color, #2a2a35);
  }

  .ch {
    position: relative;
  }

  /* Cross (+) */
  .ch-cross::before,
  .ch-cross::after {
    content: '';
    position: absolute;
    background: #4ecdc4;
  }
  .ch-cross::before {
    width: 2px;
    height: 16px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  .ch-cross::after {
    width: 16px;
    height: 2px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  /* Thick Cross */
  .ch-cross-thick::before,
  .ch-cross-thick::after {
    content: '';
    position: absolute;
    background: #4ecdc4;
  }
  .ch-cross-thick::before {
    width: 4px;
    height: 20px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  .ch-cross-thick::after {
    width: 20px;
    height: 4px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  /* Cross with Gap */
  .ch-cross-gap {
    width: 24px;
    height: 24px;
  }
  .ch-cross-gap::before {
    content: '';
    position: absolute;
    width: 2px;
    height: 8px;
    background: #4ecdc4;
    left: 50%;
    transform: translateX(-50%);
    top: 0;
    box-shadow: 0 16px 0 #4ecdc4;
  }
  .ch-cross-gap::after {
    content: '';
    position: absolute;
    width: 8px;
    height: 2px;
    background: #4ecdc4;
    top: 50%;
    transform: translateY(-50%);
    left: 0;
    box-shadow: 16px 0 0 #4ecdc4;
  }

  /* Dot */
  .ch-dot {
    width: 4px;
    height: 4px;
    background: #4ecdc4;
    border-radius: 50%;
  }

  .ch-dot-large {
    width: 8px;
    height: 8px;
    background: #4ecdc4;
    border-radius: 50%;
  }

  /* Circle */
  .ch-circle {
    width: 16px;
    height: 16px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
  }

  /* Circle with Dot */
  .ch-circle-dot {
    width: 16px;
    height: 16px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
    position: relative;
  }
  .ch-circle-dot::after {
    content: '';
    position: absolute;
    width: 4px;
    height: 4px;
    background: #4ecdc4;
    border-radius: 50%;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }

  /* Circle Crosshair */
  .ch-circle-crosshair {
    width: 20px;
    height: 20px;
    border: 2px solid #4ecdc4;
    border-radius: 50%;
    position: relative;
  }
  .ch-circle-crosshair::before,
  .ch-circle-crosshair::after {
    content: '';
    position: absolute;
    background: #4ecdc4;
  }
  .ch-circle-crosshair::before {
    width: 2px;
    height: 8px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }
  .ch-circle-crosshair::after {
    width: 8px;
    height: 2px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
  }

  /* X Mark */
  .ch-x {
    width: 16px;
    height: 16px;
    position: relative;
  }
  .ch-x::before,
  .ch-x::after {
    content: '';
    position: absolute;
    width: 2px;
    height: 20px;
    background: #4ecdc4;
    left: 50%;
    top: 50%;
  }
  .ch-x::before {
    transform: translate(-50%, -50%) rotate(45deg);
  }
  .ch-x::after {
    transform: translate(-50%, -50%) rotate(-45deg);
  }

  /* Triangle */
  .ch-triangle {
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-bottom: 14px solid #4ecdc4;
  }

  /* Chevron */
  .ch-chevron {
    width: 16px;
    height: 16px;
    position: relative;
  }
  .ch-chevron::before,
  .ch-chevron::after {
    content: '';
    position: absolute;
    width: 2px;
    height: 12px;
    background: #4ecdc4;
    bottom: 0;
  }
  .ch-chevron::before {
    left: 2px;
    transform: rotate(-30deg);
  }
  .ch-chevron::after {
    right: 2px;
    transform: rotate(30deg);
  }

  /* Unknown */
  .ch-unknown {
    color: var(--text-secondary, #888);
    font-size: 1.25rem;
  }

  .crosshair-info {
    text-align: center;
  }

  .crosshair-type {
    display: block;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-primary, #fff);
  }

  .crosshair-count {
    display: block;
    font-size: 0.7rem;
    color: var(--text-secondary, #888);
  }

  @media (max-width: 600px) {
    .heatmap-container {
      flex-direction: column;
    }

    .heatmap-y-label {
      writing-mode: horizontal-tb;
      transform: none;
    }

    .crosshair-grid {
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    }
  }
</style>
