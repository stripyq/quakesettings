---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';
import { getBaseModelName } from '../../utils/mousepadGrouping';

const allPlayers = await getCollection('players');
const players = allPlayers.filter(p => p.data.published !== false);

const mice = await getCollection('mice');
const monitors = await getCollection('monitors');
const keyboards = await getCollection('keyboards');
const mousepads = await getCollection('mousepads');
const headsets = await getCollection('headsets');

// Create lookup maps
const miceMap = new Map(mice.map(m => [m.id, m.data]));
const monitorsMap = new Map(monitors.map(m => [m.id, m.data]));
const keyboardsMap = new Map(keyboards.map(k => [k.id, k.data]));
const mousepadsMap = new Map(mousepads.map(p => [p.id, p.data]));
const headsetsMap = new Map(headsets.map(h => [h.id, h.data]));

// cm/360 calculation - two modes:
// 1. Standard (m_cpi = 0): cm/360 = (360 / (m_yaw × dpi × sens)) × 2.54
// 2. With m_cpi > 0: cm/360 = (360 / sens) × (m_cpi / dpi)
// Sources:
//   https://funender.com/quake/mouse/index.html
//   https://www.esreality.com/post/2256180/re-mouse-sensitivity/
function calculateCm360(playerData: any): number {
  if (playerData.dpi && playerData.sensitivity) {
    if (playerData.m_cpi && playerData.m_cpi > 0) {
      return Math.round(((360 / playerData.sensitivity) * (playerData.m_cpi / playerData.dpi)) * 100) / 100;
    }
    const yaw = playerData.m_yaw || 0.022;
    return Math.round(((360 / (yaw * playerData.dpi * playerData.sensitivity)) * 2.54) * 100) / 100;
  }
  return playerData.cm360 || 0;
}

// ===========================================
// SENSITIVITY STATS
// ===========================================

const cm360Values = players.map(p => calculateCm360(p.data)).filter(v => isFinite(v) && v > 0).sort((a, b) => a - b);
const avgCm360 = cm360Values.length > 0
  ? Math.round((cm360Values.reduce((a, b) => a + b, 0) / cm360Values.length) * 100) / 100
  : 0;
const medianCm360 = cm360Values.length > 0
  ? cm360Values[Math.floor(cm360Values.length / 2)]
  : 0;
const minCm360 = cm360Values.length > 0 ? Math.min(...cm360Values) : 0;
const maxCm360 = cm360Values.length > 0 ? Math.max(...cm360Values) : 0;

// eDPI stats
const edpiValues = players
  .map(p => {
    if (p.data.edpi) return p.data.edpi;
    if (p.data.dpi && p.data.sensitivity) return p.data.dpi * p.data.sensitivity;
    return NaN;
  })
  .filter(v => isFinite(v) && v > 0)
  .sort((a, b) => a - b);
const avgEdpi = edpiValues.length > 0
  ? Math.round(edpiValues.reduce((a, b) => a + b, 0) / edpiValues.length)
  : 0;
const medianEdpi = edpiValues.length > 0
  ? Math.round(edpiValues[Math.floor(edpiValues.length / 2)])
  : 0;

// cm/360 distribution buckets with accel player breakdown
const cm360BucketDefs = [
  { label: 'Very High Sens', range: '< 15 cm', min: 0, max: 15 },
  { label: 'High Sens', range: '15\u201320 cm', min: 15, max: 20 },
  { label: 'Medium-High Sens', range: '20\u201325 cm', min: 20, max: 25 },
  { label: 'Medium Sens', range: '25\u201330 cm', min: 25, max: 30 },
  { label: 'Medium-Low Sens', range: '30\u201335 cm', min: 30, max: 35 },
  { label: 'Low Sens', range: '35\u201345 cm', min: 35, max: 45 },
  { label: 'Very Low Sens', range: '45\u201355 cm', min: 45, max: 55 },
  { label: 'Extremely Low Sens', range: '> 55 cm', min: 55, max: Infinity },
];

const playerCm360Data = players.map(p => ({
  cm360: calculateCm360(p.data),
  hasAccel: !!p.data.acceleration,
})).filter(d => isFinite(d.cm360) && d.cm360 > 0);

const cm360Buckets = cm360BucketDefs.map(def => {
  const inRange = playerCm360Data.filter(d => d.cm360 >= def.min && d.cm360 < def.max);
  return {
    ...def,
    total: inRange.length,
    accel: inRange.filter(d => d.hasAccel).length,
  };
});
const maxBucketTotal = Math.max(...cm360Buckets.map(b => b.total), 1);

// ===========================================
// cm/360 vs MOUSEPAD TYPE HEATMAP
// ===========================================

function getSpeedCategory(speed: string): string | null {
  const s = speed.toLowerCase();
  if (['extremely fast', 'very fast', 'fast', 'quick', 'speed'].includes(s)) return 'Speed';
  if (['balanced'].includes(s)) return 'Balanced';
  if (['control', 'slow', 'very slow', 'extremely slow'].includes(s)) return 'Control';
  return null;
}

const padTypes = ['Speed', 'Balanced', 'Control'] as const;

// Build heatmap counts
const padHeatmap = new Map<string, number>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    if (pad?.speed) {
      const category = getSpeedCategory(pad.speed);
      if (category) {
        const cm360 = calculateCm360(p.data);
        const bucket = cm360BucketDefs.find(b => cm360 >= b.min && cm360 < b.max);
        if (bucket) {
          const key = `${bucket.label}|${category}`;
          padHeatmap.set(key, (padHeatmap.get(key) || 0) + 1);
        }
      }
    }
  }
});

// Neutral heatmap scale for cm/360 vs pad type
const neutralHeatColors = ['#21262d', '#2d333b', '#3d444d', '#4d555e', '#5d656f', '#6e7681'];
const padHeatmapMax = Math.max(...padHeatmap.values(), 1);

function getNeutralHeatColor(count: number, max: number): string {
  if (count === 0) return neutralHeatColors[0];
  const ratio = count / max;
  const index = Math.min(Math.floor(ratio * 5) + 1, 5);
  return neutralHeatColors[index];
}

const padHeatmapRows = cm360BucketDefs.map(bucket => ({
  label: bucket.label,
  range: bucket.range,
  cells: padTypes.map(type => {
    const count = padHeatmap.get(`${bucket.label}|${type}`) || 0;
    return { type, count, bg: getNeutralHeatColor(count, padHeatmapMax) };
  }),
}));

const totalPadTypePlayers = [...padHeatmap.values()].reduce((a, b) => a + b, 0);

// ===========================================
// HARDWARE STATS
// ===========================================

// Helper: sort entries with known values by count desc, "Other" second-to-last, "Unknown" last
function sortWithUnknownLast(entries: [string, number][]): [string, number][] {
  const unknown = entries.find(([k]) => k === 'Unknown');
  const other = entries.find(([k]) => k === 'Other');
  const rest = entries.filter(([k]) => k !== 'Unknown' && k !== 'Other').sort((a, b) => b[1] - a[1]);
  if (other && other[1] > 0) rest.push(other);
  if (unknown && unknown[1] > 0) rest.push(unknown);
  return rest;
}

// Mouse brand popularity (all players)
const mouseBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    const mouseData = miceMap.get(p.data.mouse);
    const brand = mouseData?.brand || 'Other';
    mouseBrands.set(brand, (mouseBrands.get(brand) || 0) + 1);
  } else {
    mouseBrands.set('Unknown', (mouseBrands.get('Unknown') || 0) + 1);
  }
});
const topMouseBrands = sortWithUnknownLast([...mouseBrands.entries()]).slice(0, 10);
const maxMouseBrandCount = topMouseBrands.length > 0 ? topMouseBrands[0][1] : 1;

// Mice (specific models) — all players
const mouseUsage = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    mouseUsage.set(p.data.mouse, (mouseUsage.get(p.data.mouse) || 0) + 1);
  } else {
    mouseUsage.set('__unknown__', (mouseUsage.get('__unknown__') || 0) + 1);
  }
});
const topMice = [...mouseUsage.entries()]
  .sort((a, b) => {
    if (a[0] === '__unknown__') return 1;
    if (b[0] === '__unknown__') return -1;
    return b[1] - a[1];
  })
  .slice(0, 10)
  .map(([id, count]) => ({
    name: id === '__unknown__' ? 'Unknown' : (miceMap.get(id)?.name || id),
    count,
    percentage: Math.round((count / players.length) * 100),
    isMuted: id === '__unknown__',
  }));
const maxMiceCount = topMice.length > 0 ? topMice[0].count : 1;

// Mousepad models (grouped by base model name) — all players
const mousepadModels = new Map<string, { count: number; brand: string }>();
players.forEach(p => {
  if (p.data.mousepad) {
    const pad = mousepadsMap.get(p.data.mousepad);
    if (pad) {
      const baseModel = getBaseModelName(pad.name);
      const existing = mousepadModels.get(baseModel);
      if (existing) {
        existing.count++;
      } else {
        mousepadModels.set(baseModel, { count: 1, brand: pad.brand });
      }
    } else {
      const existing = mousepadModels.get('Other');
      if (existing) existing.count++;
      else mousepadModels.set('Other', { count: 1, brand: 'Other' });
    }
  } else {
    const existing = mousepadModels.get('Unknown');
    if (existing) existing.count++;
    else mousepadModels.set('Unknown', { count: 1, brand: 'Unknown' });
  }
});
const topMousepads = [...mousepadModels.entries()]
  .sort((a, b) => {
    if (a[0] === 'Unknown') return 1;
    if (b[0] === 'Unknown') return -1;
    if (a[0] === 'Other') return 1;
    if (b[0] === 'Other') return -1;
    return b[1].count - a[1].count;
  })
  .slice(0, 10)
  .map(([name, data]) => ({
    name,
    count: data.count,
    percentage: Math.round((data.count / players.length) * 100),
    isMuted: name === 'Unknown' || name === 'Other',
  }));
const maxMousepadCount = topMousepads.length > 0 ? topMousepads[0].count : 1;

// Grip style distribution — all players
const gripStyles = new Map<string, number>();
players.forEach(p => {
  if (p.data.grip) {
    gripStyles.set(p.data.grip, (gripStyles.get(p.data.grip) || 0) + 1);
  } else {
    gripStyles.set('Unknown', (gripStyles.get('Unknown') || 0) + 1);
  }
});
const gripDistribution = sortWithUnknownLast([...gripStyles.entries()]);
const maxGripCount = gripDistribution.length > 0 ? gripDistribution[0][1] : 1;

// Mouse shape distribution — all players
const mouseShapeDistribution = new Map<string, number>();
players.forEach(p => {
  if (p.data.mouse) {
    const mouseData = miceMap.get(p.data.mouse);
    if (mouseData) {
      const shape = mouseData.shape || 'Other';
      mouseShapeDistribution.set(shape, (mouseShapeDistribution.get(shape) || 0) + 1);
    } else {
      mouseShapeDistribution.set('Other', (mouseShapeDistribution.get('Other') || 0) + 1);
    }
  } else {
    mouseShapeDistribution.set('Unknown', (mouseShapeDistribution.get('Unknown') || 0) + 1);
  }
});
const topMouseShapes = sortWithUnknownLast([...mouseShapeDistribution.entries()]);
const maxShapeCount = topMouseShapes.length > 0 ? topMouseShapes[0][1] : 1;

// GPU Brand distribution — all players
const gpuBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.gpuBrand) {
    const normalizedBrand = p.data.gpuBrand.toUpperCase();
    gpuBrands.set(normalizedBrand, (gpuBrands.get(normalizedBrand) || 0) + 1);
  } else {
    gpuBrands.set('Unknown', (gpuBrands.get('Unknown') || 0) + 1);
  }
});
const topGpuBrands = sortWithUnknownLast([...gpuBrands.entries()]);
const totalGpuPlayers = players.length;

// CPU Brand distribution — all players
const cpuBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.cpuBrand) {
    const normalizedBrand = p.data.cpuBrand.charAt(0).toUpperCase() + p.data.cpuBrand.slice(1).toLowerCase();
    cpuBrands.set(normalizedBrand, (cpuBrands.get(normalizedBrand) || 0) + 1);
  } else {
    cpuBrands.set('Unknown', (cpuBrands.get('Unknown') || 0) + 1);
  }
});
const topCpuBrands = sortWithUnknownLast([...cpuBrands.entries()]);
const totalCpuPlayers = players.length;

// Donut chart helpers - brand-specific colors
const brandColors: Record<string, string> = {
  'NVIDIA': '#76B900',
  'AMD': '#ED1C24',
  'INTEL': '#0071C5',
  'Intel': '#0071C5',
  'Amd': '#ED1C24',
};
const defaultDonutColors = ['#238636', '#2ea043', '#3fb950', '#56d364'];

function getBrandColor(brand: string, index: number): string {
  if (brand === 'Unknown') return '#30363d';
  return brandColors[brand] || defaultDonutColors[index % defaultDonutColors.length];
}

function buildConicGradient(entries: [string, number][], total: number): string {
  let angle = 0;
  const stops: string[] = [];
  entries.forEach(([brand, count], i) => {
    const color = getBrandColor(brand, i);
    const nextAngle = angle + (count / total) * 360;
    stops.push(`${color} ${angle.toFixed(1)}deg ${nextAngle.toFixed(1)}deg`);
    angle = nextAngle;
  });
  return `conic-gradient(${stops.join(', ')})`;
}

const gpuGradient = buildConicGradient(topGpuBrands, totalGpuPlayers);
const cpuGradient = buildConicGradient(topCpuBrands, totalCpuPlayers);

// Monitor brand distribution — all players
const monitorBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.monitor) {
    const monitorData = monitorsMap.get(p.data.monitor);
    const brand = monitorData?.brand || 'Other';
    monitorBrands.set(brand, (monitorBrands.get(brand) || 0) + 1);
  } else {
    monitorBrands.set('Unknown', (monitorBrands.get('Unknown') || 0) + 1);
  }
});
const topMonitorBrands = sortWithUnknownLast([...monitorBrands.entries()]).slice(0, 8);
const maxMonitorBrandCount = topMonitorBrands.length > 0 ? topMonitorBrands[0][1] : 1;

// Keyboard brand distribution — all players
const keyboardBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.keyboard) {
    const kbData = keyboardsMap.get(p.data.keyboard);
    const brand = kbData?.brand || 'Other';
    keyboardBrands.set(brand, (keyboardBrands.get(brand) || 0) + 1);
  } else {
    keyboardBrands.set('Unknown', (keyboardBrands.get('Unknown') || 0) + 1);
  }
});
const topKeyboardBrands = sortWithUnknownLast([...keyboardBrands.entries()]).slice(0, 8);
const maxKeyboardBrandCount = topKeyboardBrands.length > 0 ? topKeyboardBrands[0][1] : 1;

// Headset brand distribution — all players
const headsetBrands = new Map<string, number>();
players.forEach(p => {
  if (p.data.headset) {
    const hsData = headsetsMap.get(p.data.headset);
    const brand = hsData?.brand || 'Other';
    headsetBrands.set(brand, (headsetBrands.get(brand) || 0) + 1);
  } else {
    headsetBrands.set('Unknown', (headsetBrands.get('Unknown') || 0) + 1);
  }
});
const topHeadsetBrands = sortWithUnknownLast([...headsetBrands.entries()]).slice(0, 8);
const maxHeadsetBrandCount = topHeadsetBrands.length > 0 ? topHeadsetBrands[0][1] : 1;

// ===========================================
// MONITOR SIZE VS REFRESH RATE HEATMAP
// ===========================================

function parseMonitorSize(size: string): number | null {
  const match = size.match(/(\d+(?:\.\d+)?)/);
  return match ? parseFloat(match[1]) : null;
}

function parseRefreshRate(rate: string): number | null {
  // Extract highest Hz value (e.g., "240Hz (480Hz @ 1080p)" → 480)
  const hzMatches = [...rate.matchAll(/(\d+)\s*Hz/gi)];
  if (hzMatches.length > 0) {
    return Math.max(...hzMatches.map(m => parseInt(m[1])));
  }
  const match = rate.match(/(\d+)/);
  return match ? parseInt(match[1]) : null;
}

// Size groups: 6 rows
const sizeGroups = [
  { label: '≤23"', match: (s: number) => s < 24 },
  { label: '24"', match: (s: number) => s >= 24 && s < 25 },
  { label: '25"', match: (s: number) => s >= 25 && s < 26 },
  { label: '27"', match: (s: number) => s >= 26 && s < 28 },
  { label: '28"', match: (s: number) => s >= 28 && s < 30 },
  { label: '32"+', match: (s: number) => s >= 30 },
];
// Refresh groups: 6 columns
const refreshGroups = [
  { label: '60-120', match: (r: number) => r <= 120 },
  { label: '144', match: (r: number) => r > 120 && r <= 144 },
  { label: '165-180', match: (r: number) => r > 144 && r <= 180 },
  { label: '240', match: (r: number) => r > 180 && r <= 240 },
  { label: '280-499', match: (r: number) => r > 240 && r < 500 },
  { label: '500+', match: (r: number) => r >= 500 },
];

const monitorHeatmap: Map<string, number> = new Map();
players.forEach(p => {
  if (p.data.monitor) {
    const monitorData = monitorsMap.get(p.data.monitor);
    if (monitorData) {
      const size = parseMonitorSize(monitorData.size || '');
      const refresh = parseRefreshRate(monitorData.refreshRate || '');
      if (size !== null && refresh !== null) {
        const sizeGroup = sizeGroups.find(g => g.match(size));
        const refreshGroup = refreshGroups.find(g => g.match(refresh));
        if (sizeGroup && refreshGroup) {
          const key = `${sizeGroup.label}-${refreshGroup.label}`;
          monitorHeatmap.set(key, (monitorHeatmap.get(key) || 0) + 1);
        }
      }
    }
  }
});

const heatmapMax = Math.max(...monitorHeatmap.values(), 1);

const greenHeatColors = ['#21262d', '#0d3321', '#144620', '#1a5a28', '#238636', '#2ea043', '#3fb950'];

function getMonitorHeatColor(count: number, max: number): string {
  if (count === 0) return greenHeatColors[0];
  const ratio = count / max;
  const index = Math.min(Math.floor(ratio * 6) + 1, 6);
  return greenHeatColors[index];
}

// ===========================================
// GAME SETTINGS
// ===========================================

// FOV distribution
const fovValues = players.map(p => p.data.fov).filter(v => v);
const avgFov = Math.round(fovValues.reduce((a, b) => a + b, 0) / fovValues.length);
const fovDistribution = new Map<number, number>();
fovValues.forEach(fov => {
  fovDistribution.set(fov, (fovDistribution.get(fov) || 0) + 1);
});
const topFovValues = [...fovDistribution.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);
const maxFovCount = topFovValues.length > 0 ? topFovValues[0][1] : 1;

// Acceleration users
const accelUsers = players.filter(p => p.data.acceleration).length;
const accelPercentage = Math.round((accelUsers / players.length) * 100);

// Crosshair color distribution
const crosshairColors = new Map<string, number>();
players.forEach(p => {
  if (p.data.crosshairColor) {
    crosshairColors.set(p.data.crosshairColor, (crosshairColors.get(p.data.crosshairColor) || 0) + 1);
  }
});
const topCrosshairColors = [...crosshairColors.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalCrosshairColorPlayers = [...crosshairColors.values()].reduce((a, b) => a + b, 0);
const maxCrosshairColorCount = topCrosshairColors.length > 0 ? topCrosshairColors[0][1] : 1;

// Crosshair color to bar color mapping (muted versions)
const crosshairColorMap: Record<string, { bg: string; border?: string }> = {
  'Green': { bg: '#238636' },
  'Yellow': { bg: '#9e6a03' },
  'Cyan': { bg: '#1f6feb' },
  'Red': { bg: '#da3633' },
  'White': { bg: '#6e7681' },
  'Magenta': { bg: '#8957e5' },
  'Black': { bg: '#21262d', border: '1px solid #484f58' },
  'Orange': { bg: '#bd5600' },
  'Blue': { bg: '#1f6feb' },
  'Pink': { bg: '#8957e5' },
};

// Crosshair style distribution
const crosshairTypes = new Map<string, number>();
players.forEach(p => {
  const ch = p.data.crosshair || 'Unknown';
  crosshairTypes.set(ch, (crosshairTypes.get(ch) || 0) + 1);
});

const crosshairVisuals: Record<string, string> = {
  '1': 'Circle with dot',
  '2': 'Cross (+)',
  '3': 'Cross with gap',
  '4': 'Small dot',
  '5': 'Large dot',
  '6': 'Dot',
  '7': 'Thick cross',
  '8': 'Circle',
  '9': 'Cross with gap',
  '10': 'X shape',
  '11': 'Triangle',
  '12': 'Chevron',
  '13': 'Circle crosshair',
};

const crosshairStyleData = [...crosshairTypes.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8)
  .map(([type, count]) => ({
    type,
    count,
    percentage: Math.round((count / players.length) * 100),
    description: crosshairVisuals[type] || `Type ${type}`,
  }));
const maxCrosshairStyleCount = crosshairStyleData.length > 0 ? crosshairStyleData[0].count : 1;

// Enemy model distribution
const enemyModels = new Map<string, number>();
players.forEach(p => {
  if (p.data.enemyModel) {
    enemyModels.set(p.data.enemyModel, (enemyModels.get(p.data.enemyModel) || 0) + 1);
  }
});
const topEnemyModels = [...enemyModels.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 8);
const totalEnemyModelPlayers = [...enemyModels.values()].reduce((a, b) => a + b, 0);
const maxEnemyModelCount = topEnemyModels.length > 0 ? topEnemyModels[0][1] : 1;

// ===========================================
// KEY BINDINGS STATISTICS
// ===========================================

const movementPatterns = new Map<string, number>();
const jumpKeys = new Map<string, number>();

players.forEach(p => {
  const forward = (p.data.forward || 'W').toUpperCase();
  const left = (p.data.left || 'A').toUpperCase();
  const back = (p.data.back || 'S').toUpperCase();
  const right = (p.data.right || 'D').toUpperCase();

  let pattern = `${forward}${left}${back}${right}`;
  if (pattern === 'WASD') pattern = 'WASD';
  else if (pattern === 'ESDF') pattern = 'ESDF';
  else if (pattern === 'RFDG') pattern = 'RFDG';
  else if (forward.includes('ARROW') || forward.includes('UP')) pattern = 'Arrow Keys';
  else if (forward.includes('KP_') || forward.includes('NUMPAD')) pattern = 'Numpad';

  movementPatterns.set(pattern, (movementPatterns.get(pattern) || 0) + 1);

  let jump = (p.data.jump || 'Space');
  if (jump.toLowerCase() === 'space' || jump.toLowerCase() === 'spacebar') jump = 'Space';
  else if (jump.toLowerCase().includes('mouse2') || jump.toLowerCase() === 'mwheeldown' || jump.toLowerCase() === 'm2') jump = 'Mouse2';
  else if (jump.toLowerCase().includes('mwheel')) jump = 'Mwheel';
  else if (jump.toLowerCase().includes('mouse')) jump = 'Mouse Button';
  else if (jump.toLowerCase() === 'shift') jump = 'Shift';
  else if (jump.toLowerCase() === 'ctrl' || jump.toLowerCase() === 'control') jump = 'Ctrl';

  jumpKeys.set(jump, (jumpKeys.get(jump) || 0) + 1);
});

const topMovementPatterns = [...movementPatterns.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 6);
const maxMovementCount = topMovementPatterns.length > 0 ? topMovementPatterns[0][1] : 1;
const topJumpKeys = [...jumpKeys.entries()]
  .sort((a, b) => b[1] - a[1])
  .slice(0, 6);
const maxJumpCount = topJumpKeys.length > 0 ? topJumpKeys[0][1] : 1;

// ===========================================
// PLAYER STATS
// ===========================================

// Recently updated — sorted by lastUpdated (full ISO timestamp for ordering)
const recentPlayers = players
  .filter(p => p.data.lastUpdated)
  .sort((a, b) => (b.data.lastUpdated || '').localeCompare(a.data.lastUpdated || ''))
  .slice(0, 5);

// ===========================================
// WEAPON ACCURACY LEADERBOARDS
// ===========================================

// Filter: must have >= 100 team mode games (CTF + TDM)
// Game counts come from YAML only (synced from HoQ via scripts/sync-hoq-games.cjs)
function getCompetitiveGames(d: any): number {
  const ctf = d.ctfGames || 0;
  const tdm = d.tdmGames || 0;
  return ctf + tdm;
}
const accuracyEligible = players.filter(p => getCompetitiveGames(p.data) >= 100);

const topRgAccuracy = accuracyEligible
  .filter(p => p.data.accuracy_rg != null)
  .sort((a, b) => b.data.accuracy_rg! - a.data.accuracy_rg!)
  .slice(0, 20)
  .map(p => ({ id: p.id, name: p.data.name, value: p.data.accuracy_rg! }));

const topLgAccuracy = accuracyEligible
  .filter(p => p.data.accuracy_lg != null)
  .sort((a, b) => b.data.accuracy_lg! - a.data.accuracy_lg!)
  .slice(0, 20)
  .map(p => ({ id: p.id, name: p.data.name, value: p.data.accuracy_lg! }));

const topRlAccuracy = accuracyEligible
  .filter(p => p.data.accuracy_rl != null)
  .sort((a, b) => b.data.accuracy_rl! - a.data.accuracy_rl!)
  .slice(0, 20)
  .map(p => ({ id: p.id, name: p.data.name, value: p.data.accuracy_rl! }));

// ===========================================
// INTERESTING FACTS
// ===========================================

const playersWithValidCm360 = players.filter(p => {
  const cm = calculateCm360(p.data);
  return isFinite(cm) && cm > 0;
});
const lowestSensPlayer = playersWithValidCm360.reduce((prev, curr) =>
  calculateCm360(curr.data) > calculateCm360(prev.data) ? curr : prev
);
const highestSensPlayer = playersWithValidCm360.reduce((prev, curr) =>
  calculateCm360(curr.data) < calculateCm360(prev.data) ? curr : prev
);

// Highest and lowest FOV
const playersWithFov = players.filter(p => p.data.fov);
const highestFovPlayer = playersWithFov.length > 0
  ? playersWithFov.reduce((prev, curr) => curr.data.fov > prev.data.fov ? curr : prev)
  : null;
const lowestFovPlayer = playersWithFov.length > 0
  ? playersWithFov.reduce((prev, curr) => curr.data.fov < prev.data.fov ? curr : prev)
  : null;

// Format cm/360 values
function formatCm360(value: number): string {
  const fixed = value.toFixed(2);
  return fixed.endsWith('.00') ? Math.round(value).toString() : fixed;
}

// Summary card: most popular mouse
const topMouseName = topMice.length > 0 ? topMice[0].name : 'N/A';

// Format bind strings
function formatBindString(bind: string): string {
  return bind.replace(/^(MOUSE[12])([A-Z])/, '$1 $2');
}

const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;

const schema = {
  "@context": "https://schema.org",
  "@type": "Dataset",
  "name": "Quake Live Player Statistics",
  "description": "Aggregated statistics from competitive Quake Live players",
  "url": "https://stripyq.github.io/quakesettings/stats/"
};
---

<BaseLayout title="Statistics" description="Aggregated statistics from 96+ Quake Live players. Most popular mice, sensitivity distributions, FOV, crosshairs, and hardware trends." schema={schema} ogImage="/images/og/stats.jpg">
  <div class="stats-page">
    <div class="page-header">
      <h1>Player Statistics</h1>
      <p>Aggregated data from {players.length} Quake Live players</p>
    </div>

    <!-- ========== SUMMARY CARDS ========== -->
    <div class="s-summary-cards">
      <div class="s-summary-card">
        <span class="s-summary-value">{formatCm360(avgCm360)}</span>
        <span class="s-summary-label">Avg cm/360</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{formatCm360(medianCm360)}</span>
        <span class="s-summary-label">Median cm/360</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{avgEdpi}</span>
        <span class="s-summary-label">Avg eDPI</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{medianEdpi}</span>
        <span class="s-summary-label">Median eDPI</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{accelPercentage}%</span>
        <span class="s-summary-label">Accel Users</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{avgFov}&deg;</span>
        <span class="s-summary-label">Avg FOV</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value s-summary-value-sm">{topMouseName}</span>
        <span class="s-summary-label">Top Mouse</span>
      </div>
      <div class="s-summary-card">
        <span class="s-summary-value">{players.length}</span>
        <span class="s-summary-label">Total Players</span>
      </div>
    </div>

    <!-- ========== SECTION 1: HARDWARE ========== -->
    <div class="s-section-header" style="--section-color: #238636">
      <div class="s-section-icon" style="background: #238636">&#128433;&#65039;</div>
      <span class="s-section-title" style="color: #238636">HARDWARE</span>
    </div>

    <!-- Row 1: Mouse Brands + Top Mice -->
    <div class="s-two-col">
      <div class="s-card">
        <h2 class="s-card-title">Top Mouse Brands</h2>
        <div class="s-bar-list">
          {topMouseBrands.map(([brand, count]) => (
            <div class={`s-bar-row ${brand === 'Unknown' || brand === 'Other' ? 's-bar-muted' : ''}`}>
              <span class="s-bar-label">{brand}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxMouseBrandCount) * 100}%; background: ${brand === 'Unknown' || brand === 'Other' ? '#30363d' : '#238636'}`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">Top Mice</h2>
        <div class="s-bar-list">
          {topMice.slice(0, 8).map((mouse) => (
            <div class={`s-bar-row ${mouse.isMuted ? 's-bar-muted' : ''}`}>
              <span class="s-bar-label s-bar-label-wide">{mouse.name}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(mouse.count / maxMiceCount) * 100}%; background: ${mouse.isMuted ? '#30363d' : '#238636'}`}>
                  <span class="s-bar-count">{mouse.count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{mouse.percentage}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- Row 2: Mousepads + Grip Style + Mouse Shape -->
    <div class="s-three-col">
      <div class="s-card">
        <h2 class="s-card-title">Top Mousepads</h2>
        <p class="s-card-sub">Grouped by model (all sizes)</p>
        <div class="s-bar-list">
          {topMousepads.slice(0, 8).map((pad) => (
            <div class={`s-bar-row ${pad.isMuted ? 's-bar-muted' : ''}`}>
              <span class="s-bar-label">{pad.name}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(pad.count / maxMousepadCount) * 100}%; background: ${pad.isMuted ? '#30363d' : '#238636'}`}>
                  <span class="s-bar-count">{pad.count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{pad.percentage}%</span>
            </div>
          ))}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">Grip Style</h2>
        <div class="s-vbar-chart">
          {gripDistribution.map(([style, count]) => {
            const pct = Math.round((count / players.length) * 100);
            const isMuted = style === 'Unknown' || style === 'Other';
            return (
              <div class="s-vbar-item">
                <span class={`s-vbar-pct ${isMuted ? 's-vbar-muted' : ''}`}>{pct}%</span>
                <div class="s-vbar" style={`height: ${(count / maxGripCount) * 100}px; background: ${isMuted ? '#30363d' : '#238636'}`}></div>
                <span class={`s-vbar-label ${isMuted ? 's-vbar-muted' : ''}`}>{style}</span>
              </div>
            );
          })}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">Mouse Shape</h2>
        <div class="s-vbar-chart">
          {topMouseShapes.map(([shape, count]) => {
            const pct = Math.round((count / players.length) * 100);
            const isMuted = shape === 'Unknown' || shape === 'Other';
            const shortLabel = shape === 'Ambidextrous' ? 'Ambi' : shape === 'Symmetrical' ? 'Sym' : shape === 'Ergonomic' ? 'Ergo' : shape;
            return (
              <div class="s-vbar-item">
                <span class={`s-vbar-pct ${isMuted ? 's-vbar-muted' : ''}`}>{pct}%</span>
                <div class="s-vbar" style={`height: ${(count / maxShapeCount) * 100}px; background: ${isMuted ? '#30363d' : '#238636'}`}></div>
                <span class={`s-vbar-label ${isMuted ? 's-vbar-muted' : ''}`}>{shortLabel}</span>
              </div>
            );
          })}
        </div>
      </div>
    </div>

    <!-- Row 3: Monitor Brands (40%) + Heatmap (60%) -->
    <div class="s-hw-row3">
      <div class="s-card">
        <h2 class="s-card-title">Top Monitor Brands</h2>
        <div class="s-bar-list">
          {topMonitorBrands.map(([brand, count]) => (
            <div class={`s-bar-row ${brand === 'Unknown' || brand === 'Other' ? 's-bar-muted' : ''}`}>
              <span class="s-bar-label">{brand}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxMonitorBrandCount) * 100}%; background: ${brand === 'Unknown' || brand === 'Other' ? '#30363d' : '#238636'}`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">Monitor Size vs Refresh Rate</h2>
        <div class="s-heatmap-scroll">
          <div class="s-heatmap-grid" style={`grid-template-columns: auto repeat(${refreshGroups.length}, 65px)`}>
            <div class="s-heatmap-cell s-hm-corner"></div>
            {refreshGroups.map(rg => (
              <div class="s-heatmap-cell s-hm-header">{rg.label}Hz</div>
            ))}
            {[...sizeGroups].reverse().map(sg => (
              <>
                <div class="s-heatmap-cell s-hm-rowlabel">{sg.label}</div>
                {refreshGroups.map(rg => {
                  const count = monitorHeatmap.get(`${sg.label}-${rg.label}`) || 0;
                  return (
                    <div
                      class="s-heatmap-cell s-hm-data"
                      style={`background-color: ${getMonitorHeatColor(count, heatmapMax)}`}
                      title={`${sg.label} @ ${rg.label}Hz: ${count} players`}
                    >
                      {count > 0 ? count : ''}
                    </div>
                  );
                })}
              </>
            ))}
          </div>
        </div>
        <div class="s-heatmap-legend">
          <span class="s-heatmap-legend-label">0</span>
          <div class="s-heatmap-legend-bar">
            {greenHeatColors.map(c => (
              <div class="s-heatmap-legend-swatch" style={`background: ${c}`}></div>
            ))}
          </div>
          <span class="s-heatmap-legend-label">Max</span>
        </div>
      </div>
    </div>

    <!-- Row 4: Keyboard Brands + Headset Brands + GPU/CPU -->
    <div class="s-three-col">
      <div class="s-card">
        <h2 class="s-card-title">Top Keyboard Brands</h2>
        <div class="s-bar-list">
          {topKeyboardBrands.map(([brand, count]) => (
            <div class={`s-bar-row ${brand === 'Unknown' || brand === 'Other' ? 's-bar-muted' : ''}`}>
              <span class="s-bar-label">{brand}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxKeyboardBrandCount) * 100}%; background: ${brand === 'Unknown' || brand === 'Other' ? '#30363d' : '#238636'}`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">Top Headset Brands</h2>
        <div class="s-bar-list">
          {topHeadsetBrands.map(([brand, count]) => (
            <div class={`s-bar-row ${brand === 'Unknown' || brand === 'Other' ? 's-bar-muted' : ''}`}>
              <span class="s-bar-label">{brand}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxHeadsetBrandCount) * 100}%; background: ${brand === 'Unknown' || brand === 'Other' ? '#30363d' : '#238636'}`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">GPU / CPU Brand</h2>
        <div class="s-donut-row">
          <div class="s-donut-group">
            <h3 class="s-subsection-title">GPU ({totalGpuPlayers})</h3>
            <div class="s-donut" style={`background: ${gpuGradient}`}>
              <div class="s-donut-hole"></div>
            </div>
            <div class="s-donut-legend">
              {topGpuBrands.map(([brand, count], i) => (
                <div class="s-donut-legend-item">
                  <span class="s-donut-swatch" style={`background: ${getBrandColor(brand, i)}`}></span>
                  <span>{brand} {Math.round((count / totalGpuPlayers) * 100)}%</span>
                </div>
              ))}
            </div>
          </div>
          <div class="s-donut-group">
            <h3 class="s-subsection-title">CPU ({totalCpuPlayers})</h3>
            <div class="s-donut" style={`background: ${cpuGradient}`}>
              <div class="s-donut-hole"></div>
            </div>
            <div class="s-donut-legend">
              {topCpuBrands.map(([brand, count], i) => (
                <div class="s-donut-legend-item">
                  <span class="s-donut-swatch" style={`background: ${getBrandColor(brand, i)}`}></span>
                  <span>{brand} {Math.round((count / totalCpuPlayers) * 100)}%</span>
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ========== SECTION 2: SENSITIVITY ========== -->
    <div class="s-section-header" style="--section-color: #1f6feb">
      <div class="s-section-icon" style="background: #1f6feb">&#127919;</div>
      <span class="s-section-title" style="color: #1f6feb">SENSITIVITY</span>
    </div>

    <div class="s-two-col">
      <!-- cm/360 Distribution -->
      <div class="s-card">
        <h2 class="s-card-title">cm/360 Distribution</h2>
        <div class="s-cm360-legend">
          <span class="s-cm360-legend-item"><span class="s-cm360-swatch" style="background: #1f6feb"></span> All players</span>
          <span class="s-cm360-legend-item"><span class="s-cm360-swatch" style="background: #58a6ff"></span> Accel players</span>
        </div>
        <div class="s-cm360-chart">
          {cm360Buckets.map(bucket => (
            <div class="s-cm360-row">
              <div class="s-cm360-label">
                <span class="s-cm360-name">{bucket.label}</span>
                <span class="s-cm360-range">{bucket.range}</span>
              </div>
              <div class="s-cm360-bars">
                <div class="s-cm360-track">
                  {bucket.total > 0 && (
                    <div class="s-cm360-fill" style={`width: ${(bucket.total / maxBucketTotal) * 100}%; background: #1f6feb`}>
                      <span class="s-cm360-fill-count">{bucket.total}</span>
                    </div>
                  )}
                </div>
                {bucket.accel > 0 && (
                  <div class="s-cm360-track s-cm360-track-sm">
                    <div class="s-cm360-fill" style={`width: ${(bucket.accel / maxBucketTotal) * 100}%; background: #58a6ff`}>
                      <span class="s-cm360-fill-count">{bucket.accel}</span>
                    </div>
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
        <div class="s-cm360-summary">
          <span><strong>Average:</strong> {formatCm360(avgCm360)}</span>
          <span><strong>Median:</strong> {formatCm360(medianCm360)}</span>
          <span><strong>Min/Max:</strong> {formatCm360(minCm360)} / {formatCm360(maxCm360)}</span>
        </div>
        <p class="s-cm360-note"><em>Note:</em> For accel players, cm/360 represents base (slowest) sensitivity</p>
      </div>

      <!-- cm/360 vs Mousepad Type -->
      <div class="s-card">
        <h2 class="s-card-title">cm/360 vs Mousepad Type</h2>
        <p class="s-card-sub">{totalPadTypePlayers} players with mousepad speed data</p>
        <div class="s-pad-heatmap-grid">
          <div class="s-pad-corner"></div>
          <div class="s-pad-colheader">Speed</div>
          <div class="s-pad-colheader">Balanced</div>
          <div class="s-pad-colheader">Control</div>
          {padHeatmapRows.map(row => (
            <>
              <div class="s-pad-rowlabel">
                <span class="s-pad-rowlabel-name">{row.label}</span>
                <span class="s-pad-rowlabel-range">{row.range}</span>
              </div>
              {row.cells.map(cell => (
                <div
                  class="s-pad-cell"
                  style={`background-color: ${cell.bg}`}
                  title={`${row.label} + ${cell.type}: ${cell.count} players`}
                >
                  {cell.count > 0 ? cell.count : ''}
                </div>
              ))}
            </>
          ))}
        </div>
        <div class="s-heatmap-legend">
          <span class="s-heatmap-legend-label">0</span>
          <div class="s-heatmap-legend-bar">
            {neutralHeatColors.map(c => (
              <div class="s-heatmap-legend-swatch" style={`background: ${c}`}></div>
            ))}
          </div>
          <span class="s-heatmap-legend-label">Max</span>
        </div>
      </div>
    </div>

    <!-- ========== SECTION 3: GAME SETTINGS ========== -->
    <div class="s-section-header" style="--section-color: #8957e5">
      <div class="s-section-icon" style="background: #8957e5">&#9881;&#65039;</div>
      <span class="s-section-title" style="color: #8957e5">GAME SETTINGS</span>
    </div>

    <div class="s-four-col">
      <!-- FOV Distribution -->
      <div class="s-card">
        <h2 class="s-card-title">FOV Distribution</h2>
        <p class="s-card-sub">Average: {avgFov}&deg;</p>
        <div class="s-bar-list">
          {topFovValues.map(([fov, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label s-bar-label-narrow">{fov}&deg;</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxFovCount) * 100}%; background: #8957e5`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- Crosshair Color (special: bars ARE the color) -->
      <div class="s-card">
        <h2 class="s-card-title">Crosshair Color</h2>
        <p class="s-card-sub">{totalCrosshairColorPlayers} players</p>
        <div class="s-bar-list">
          {topCrosshairColors.map(([color, count]) => {
            const colorStyle = crosshairColorMap[color] || { bg: '#8957e5' };
            return (
              <div class="s-bar-row">
                <span class="s-bar-label s-bar-label-narrow">{color}</span>
                <div class="s-bar-container">
                  <div
                    class="s-bar"
                    style={`width: ${(count / maxCrosshairColorCount) * 100}%; background: ${colorStyle.bg}; ${colorStyle.border ? `border: ${colorStyle.border}` : ''}`}
                  >
                    <span class="s-bar-count">{count}</span>
                  </div>
                </div>
                <span class="s-bar-pct">{Math.round((count / totalCrosshairColorPlayers) * 100)}%</span>
              </div>
            );
          })}
        </div>
      </div>

      <!-- Crosshair Style -->
      <div class="s-card">
        <h2 class="s-card-title">Crosshair Style</h2>
        <p class="s-card-sub">cg_drawCrosshair</p>
        <div class="s-bar-list">
          {crosshairStyleData.map(({ type, count, percentage, description }) => (
            <div class="s-bar-row">
              <span class="s-bar-label s-bar-label-narrow" title={description}>Type {type}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxCrosshairStyleCount) * 100}%; background: #8957e5`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{percentage}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- Enemy Model -->
      <div class="s-card">
        <h2 class="s-card-title">Enemy Model</h2>
        <p class="s-card-sub">{totalEnemyModelPlayers} players</p>
        <div class="s-bar-list">
          {topEnemyModels.map(([model, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label s-bar-label-narrow">{model}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxEnemyModelCount) * 100}%; background: #8957e5`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / totalEnemyModelPlayers) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- ========== SECTION: WEAPON ACCURACY ========== -->
    <div class="s-section-header" style="--section-color: #f85149">
      <div class="s-section-icon" style="background: #f85149">&#127919;</div>
      <span class="s-section-title" style="color: #f85149">WEAPON ACCURACY LEADERBOARDS</span>
      <span class="s-section-attr">Stats via <a href="http://88.214.20.58/matches/" target="_blank" rel="noopener">HoQ</a> &middot; Players with 100+ CTF and/or TDM games</span>
    </div>

    <div class="s-three-col">
      <div class="s-card">
        <h2 class="s-card-title">Top 20 RG Accuracy</h2>
        <p class="s-card-sub">Railgun</p>
        <div class="s-leaderboard">
          {topRgAccuracy.map((p, i) => (
            <div class="s-lb-row">
              <span class="s-lb-rank">{i + 1}.</span>
              <a href={`${base}players/${p.id}/`} class="s-lb-name">{p.name}</a>
              <span class="s-lb-value">{p.value}%</span>
            </div>
          ))}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">Top 20 LG Accuracy</h2>
        <p class="s-card-sub">Lightning Gun</p>
        <div class="s-leaderboard">
          {topLgAccuracy.map((p, i) => (
            <div class="s-lb-row">
              <span class="s-lb-rank">{i + 1}.</span>
              <a href={`${base}players/${p.id}/`} class="s-lb-name">{p.name}</a>
              <span class="s-lb-value">{p.value}%</span>
            </div>
          ))}
        </div>
      </div>

      <div class="s-card">
        <h2 class="s-card-title">Top 20 RL Accuracy</h2>
        <p class="s-card-sub">Rocket Launcher</p>
        <div class="s-leaderboard">
          {topRlAccuracy.map((p, i) => (
            <div class="s-lb-row">
              <span class="s-lb-rank">{i + 1}.</span>
              <a href={`${base}players/${p.id}/`} class="s-lb-name">{p.name}</a>
              <span class="s-lb-value">{p.value}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- ========== SECTION 4: CONTROLS ========== -->
    <div class="s-section-header" style="--section-color: #da3633">
      <div class="s-section-icon" style="background: #da3633">&#9000;&#65039;</div>
      <span class="s-section-title" style="color: #da3633">CONTROLS</span>
    </div>

    <div class="s-two-col">
      <!-- Movement Keys -->
      <div class="s-card">
        <h2 class="s-card-title">Movement Keys</h2>
        <div class="s-bar-list">
          {topMovementPatterns.map(([pattern, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label s-bar-label-mono">{formatBindString(pattern)}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxMovementCount) * 100}%; background: #da3633`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>

      <!-- Jump Key -->
      <div class="s-card">
        <h2 class="s-card-title">Jump Key</h2>
        <div class="s-bar-list">
          {topJumpKeys.map(([key, count]) => (
            <div class="s-bar-row">
              <span class="s-bar-label s-bar-label-mono">{key}</span>
              <div class="s-bar-container">
                <div class="s-bar" style={`width: ${(count / maxJumpCount) * 100}%; background: #da3633`}>
                  <span class="s-bar-count">{count}</span>
                </div>
              </div>
              <span class="s-bar-pct">{Math.round((count / players.length) * 100)}%</span>
            </div>
          ))}
        </div>
      </div>
    </div>

    <!-- ========== SECTION 5: PLAYERS ========== -->
    <div class="s-section-header" style="--section-color: #d29922">
      <div class="s-section-icon" style="background: #d29922">&#128101;</div>
      <span class="s-section-title" style="color: #d29922">PLAYERS</span>
    </div>

    <div class="s-two-col">
      <!-- Recently Updated -->
      {recentPlayers.length > 0 && (
        <div class="s-card">
          <h2 class="s-card-title">Recently Updated</h2>
          <div class="s-recent-list">
            {recentPlayers.map((p, i) => (
              <div class="s-recent-item">
                <span class="s-recent-rank">{i + 1}</span>
                <a href={`${base}players/${p.id}/`} class="s-recent-name">{p.data.name}</a>
                {p.data.country && <span class="s-recent-country">{p.data.country}</span>}
                <span class="s-recent-date">{p.data.lastUpdated?.substring(0, 10)}</span>
              </div>
            ))}
          </div>
        </div>
      )}

      <!-- Interesting Facts -->
      <div class="s-card">
        <h2 class="s-card-title">Interesting Facts</h2>
        <div class="s-facts-grid">
          <div class="s-fact-card">
            <span class="s-fact-label">Highest Sensitivity</span>
            <a href={`${base}players/${highestSensPlayer.id}/`} class="s-fact-value">{highestSensPlayer.data.name}</a>
            <span class="s-fact-detail">{formatCm360(calculateCm360(highestSensPlayer.data))} cm/360</span>
          </div>
          <div class="s-fact-card">
            <span class="s-fact-label">Lowest Sensitivity</span>
            <a href={`${base}players/${lowestSensPlayer.id}/`} class="s-fact-value">{lowestSensPlayer.data.name}</a>
            <span class="s-fact-detail">{formatCm360(calculateCm360(lowestSensPlayer.data))} cm/360</span>
          </div>
          {highestFovPlayer && (
            <div class="s-fact-card">
              <span class="s-fact-label">Highest FOV</span>
              <a href={`${base}players/${highestFovPlayer.id}/`} class="s-fact-value">{highestFovPlayer.data.name}</a>
              <span class="s-fact-detail">{highestFovPlayer.data.fov}&deg;</span>
            </div>
          )}
          {lowestFovPlayer && (
            <div class="s-fact-card">
              <span class="s-fact-label">Lowest FOV</span>
              <a href={`${base}players/${lowestFovPlayer.id}/`} class="s-fact-value">{lowestFovPlayer.data.name}</a>
              <span class="s-fact-detail">{lowestFovPlayer.data.fov}&deg;</span>
            </div>
          )}
        </div>
      </div>
    </div>

    <div class="s-disclaimer">
      <p><strong>cm/360&deg;</strong> = how many centimeters it takes for you to complete a 360 degree turn. This is also called your real sensitivity.</p>
      <p><strong>eDPI</strong> = mouse DPI &times; ingame sens</p>
      <p class="s-disclaimer-note"><em>Note:</em> Does not account for in-game acceleration. If mouse acceleration is enabled, the movement distance required to turn 360&deg; will of course vary depending on the speed of your mouse movement. But can still be used as comparable &ldquo;base&rdquo; sensitivity.</p>
    </div>

    <footer class="s-footer">
      <p>Duel ratings via <a href="https://qlstats.net/ranks/duel/1" target="_blank" rel="noopener">QLStats</a> &bull; CTF/TDM ratings via <a href="http://88.214.20.58/ratings/" target="_blank" rel="noopener">HoQ community tracker</a></p>
    </footer>
  </div>
</BaseLayout>

<style>
  /* ===========================================
     Stats Page - GitHub-Inspired Dark Theme
     =========================================== */

  .stats-page {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
    max-width: 1200px;
    margin: 0 auto;
  }

  /* --- Summary Cards --- */
  .s-summary-cards {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
  }

  .s-summary-card {
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 8px;
    padding: 16px;
    text-align: center;
  }

  .s-summary-value {
    display: block;
    font-size: 1.75rem;
    font-weight: 600;
    color: #f0f6fc;
    line-height: 1.2;
  }

  .s-summary-value-sm {
    font-size: 0.95rem;
    line-height: 1.8;
  }

  .s-summary-label {
    display: block;
    font-size: 0.8rem;
    color: #8b949e;
    margin-top: 0.35rem;
  }

  /* --- Section Headers --- */
  .s-section-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid #30363d;
    margin-top: 0.5rem;
  }

  .s-section-icon {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    line-height: 1;
  }

  .s-section-title {
    font-size: 0.85rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .s-section-attr {
    margin-left: auto;
    font-size: 0.75rem;
    color: #484f58;
  }

  .s-section-attr a {
    color: #8b949e;
    text-decoration: none;
  }

  .s-section-attr a:hover {
    color: #c9d1d9;
    text-decoration: underline;
  }

  /* --- Grid Layouts --- */
  .s-two-col {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 24px;
  }

  .s-three-col {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 24px;
  }

  .s-four-col {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
  }

  .s-hw-row3 {
    display: grid;
    grid-template-columns: 2fr 3fr;
    gap: 24px;
  }

  /* --- Cards --- */
  .s-card {
    background: #161b22;
    border: 1px solid #30363d;
    border-radius: 8px;
    padding: 1.25rem;
  }

  .s-card-wide {
    width: 100%;
  }

  .s-card-title {
    font-size: 0.95rem;
    font-weight: 600;
    color: #f0f6fc;
    margin-bottom: 0.75rem;
  }

  .s-card-sub {
    font-size: 0.8rem;
    color: #8b949e;
    margin-top: -0.5rem;
    margin-bottom: 0.75rem;
  }

  .s-subsection-title {
    font-size: 0.8rem;
    color: #8b949e;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  /* --- Bar Chart Rows --- */
  .s-bar-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .s-bar-list-compact {
    gap: 4px;
  }

  .s-bar-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .s-bar-label {
    width: 100px;
    min-width: 100px;
    text-align: right;
    font-size: 0.8rem;
    color: #8b949e;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .s-bar-label-wide {
    width: 160px;
    min-width: 160px;
    font-size: 0.75rem;
    line-height: 1.3;
    white-space: normal;
  }

  .s-bar-label-narrow {
    width: 60px;
    min-width: 60px;
    font-size: 0.7rem;
  }

  .s-bar-label-mono {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    letter-spacing: 0.03em;
  }

  .s-bar-container {
    flex: 1;
    background: #21262d;
    height: 20px;
    border-radius: 4px;
    overflow: hidden;
  }

  .s-bar {
    height: 100%;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 6px;
    min-width: fit-content;
    transition: width 0.3s ease;
  }

  .s-bar-count {
    font-size: 0.7rem;
    font-weight: 500;
    color: #f0f6fc;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  }

  .s-bar-pct {
    width: 40px;
    min-width: 40px;
    text-align: right;
    font-size: 0.75rem;
    color: #8b949e;
  }

  /* --- Muted styles for Unknown/Other --- */
  .s-bar-muted .s-bar-label,
  .s-bar-muted .s-bar-pct {
    color: #484f58;
  }

  .s-vbar-muted {
    color: #484f58 !important;
  }

  /* --- Vertical Bar Charts --- */
  .s-vbar-chart {
    display: flex;
    justify-content: center;
    gap: 20px;
    height: 160px;
    margin-top: 24px;
  }

  .s-vbar-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;
    gap: 6px;
  }

  .s-vbar-pct {
    font-size: 0.75rem;
    font-weight: 500;
    color: #c9d1d9;
  }

  .s-vbar {
    width: 45px;
    border-radius: 4px 4px 0 0;
    min-height: 8px;
  }

  .s-vbar-label {
    font-size: 0.7rem;
    color: #8b949e;
    text-align: center;
    white-space: nowrap;
  }

  /* --- Donut Charts --- */
  .s-donut-row {
    display: flex;
    justify-content: space-around;
    gap: 16px;
  }

  .s-donut-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .s-donut {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    position: relative;
  }

  .s-donut-hole {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 46px;
    height: 46px;
    background: #161b22;
    border-radius: 50%;
  }

  .s-donut-legend {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .s-donut-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.7rem;
    color: #8b949e;
  }

  .s-donut-swatch {
    width: 8px;
    height: 8px;
    border-radius: 2px;
    flex-shrink: 0;
  }

  /* --- cm/360 Distribution --- */
  .s-cm360-legend {
    display: flex;
    gap: 1.25rem;
    margin-bottom: 0.75rem;
  }

  .s-cm360-legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.75rem;
    color: #8b949e;
  }

  .s-cm360-swatch {
    width: 10px;
    height: 10px;
    border-radius: 2px;
    display: inline-block;
  }

  .s-cm360-chart {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .s-cm360-row {
    display: flex;
    align-items: flex-start;
    gap: 8px;
  }

  .s-cm360-label {
    width: 120px;
    min-width: 120px;
    text-align: right;
    display: flex;
    flex-direction: column;
  }

  .s-cm360-name {
    font-size: 0.75rem;
    color: #c9d1d9;
    line-height: 1.2;
  }

  .s-cm360-range {
    font-size: 0.65rem;
    color: #484f58;
  }

  .s-cm360-bars {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .s-cm360-track {
    height: 20px;
    background: #21262d;
    border-radius: 4px;
    overflow: hidden;
  }

  .s-cm360-track-sm {
    height: 10px;
    border-radius: 3px;
  }

  .s-cm360-fill {
    height: 100%;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 4px;
    min-width: fit-content;
  }

  .s-cm360-fill-count {
    font-size: 0.65rem;
    font-weight: 500;
    color: #f0f6fc;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
  }

  .s-cm360-track-sm .s-cm360-fill-count {
    font-size: 0.55rem;
  }

  .s-cm360-summary {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px solid #30363d;
    font-size: 0.8rem;
    color: #c9d1d9;
  }

  .s-cm360-note {
    margin-top: 0.5rem;
    font-size: 0.75rem;
    color: #8b949e;
  }

  .s-cm360-note em {
    color: #c9d1d9;
    font-style: normal;
    font-weight: 600;
  }

  /* --- Heatmaps (shared) --- */
  .s-heatmap-scroll {
    overflow-x: auto;
  }

  .s-heatmap-grid {
    display: grid;
    gap: 2px;
    width: fit-content;
  }

  .s-heatmap-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.75rem;
    font-weight: 500;
    color: #f0f6fc;
    min-height: 28px;
  }

  .s-hm-corner {
    /* empty */
  }

  .s-hm-header {
    color: #8b949e;
    font-size: 0.65rem;
    font-weight: 600;
  }

  .s-hm-rowlabel {
    color: #8b949e;
    font-size: 0.7rem;
    font-weight: 600;
    justify-content: flex-end;
    padding-right: 8px;
  }

  .s-hm-data {
    border-radius: 3px;
    cursor: default;
    transition: transform 0.1s;
  }

  .s-hm-data:hover {
    transform: scale(1.08);
    z-index: 1;
  }

  .s-heatmap-legend {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    margin-top: 0.75rem;
  }

  .s-heatmap-legend-label {
    font-size: 0.65rem;
    color: #8b949e;
  }

  .s-heatmap-legend-bar {
    display: flex;
    gap: 2px;
  }

  .s-heatmap-legend-swatch {
    width: 20px;
    height: 10px;
    border-radius: 2px;
  }

  /* --- cm/360 vs Pad Type Heatmap --- */
  .s-pad-heatmap-grid {
    display: grid;
    grid-template-columns: 120px repeat(3, 1fr);
    gap: 4px;
  }

  .s-pad-corner {
    /* empty */
  }

  .s-pad-colheader {
    text-align: center;
    font-size: 0.8rem;
    font-weight: 600;
    color: #c9d1d9;
    padding: 0.4rem 0;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .s-pad-rowlabel {
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: right;
    padding-right: 0.5rem;
  }

  .s-pad-rowlabel-name {
    font-size: 0.7rem;
    color: #c9d1d9;
    line-height: 1.2;
  }

  .s-pad-rowlabel-range {
    font-size: 0.6rem;
    color: #484f58;
  }

  .s-pad-cell {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 28px;
    border-radius: 3px;
    font-size: 0.8rem;
    font-weight: 500;
    color: #f0f6fc;
    cursor: default;
    transition: transform 0.1s;
  }

  .s-pad-cell:hover {
    transform: scale(1.05);
    z-index: 1;
  }

  /* --- Leaderboard --- */
  .s-leaderboard {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .s-lb-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 8px;
    border-radius: 4px;
  }

  .s-lb-row:nth-child(odd) {
    background: #21262d;
  }

  .s-lb-rank {
    width: 24px;
    min-width: 24px;
    font-size: 0.75rem;
    font-weight: 600;
    color: #484f58;
    text-align: right;
  }

  .s-lb-row:nth-child(1) .s-lb-rank,
  .s-lb-row:nth-child(2) .s-lb-rank,
  .s-lb-row:nth-child(3) .s-lb-rank {
    color: #f85149;
  }

  .s-lb-name {
    flex: 1;
    font-size: 0.8rem;
    color: var(--link-internal, #4ecdc4);
    text-decoration: none;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .s-lb-name:hover {
    text-decoration: underline;
  }

  .s-lb-value {
    font-size: 0.8rem;
    font-weight: 600;
    color: #f0f6fc;
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
    min-width: 36px;
    text-align: right;
  }

  /* --- Recently Updated --- */
  .s-recent-list {
    display: flex;
    flex-direction: column;
    gap: 0;
  }

  .s-recent-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: #21262d;
    border-radius: 6px;
    margin-bottom: 6px;
  }

  .s-recent-item:last-child {
    margin-bottom: 0;
  }

  .s-recent-rank {
    font-size: 0.8rem;
    font-weight: 600;
    color: #484f58;
    min-width: 1.5rem;
  }

  .s-recent-name {
    flex: 1;
    color: var(--link-internal, #4ecdc4);
    text-decoration: none;
    font-weight: 500;
  }

  .s-recent-name:hover {
    text-decoration: underline;
  }

  .s-recent-country {
    font-size: 0.75rem;
    color: #8b949e;
  }

  .s-recent-date {
    font-size: 0.75rem;
    color: #8b949e;
  }

  /* --- Interesting Facts --- */
  .s-facts-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .s-fact-card {
    background: #21262d;
    border-radius: 6px;
    border-left: 3px solid #30363d;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .s-fact-label {
    font-size: 0.7rem;
    color: #8b949e;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }

  .s-fact-value {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--link-internal, #4ecdc4);
    text-decoration: none;
  }

  .s-fact-value:hover {
    text-decoration: underline;
  }

  .s-fact-detail {
    font-size: 0.8rem;
    color: #c9d1d9;
  }

  /* --- Footer --- */
  .s-footer {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid #30363d;
    text-align: center;
  }

  .s-footer p {
    font-size: 0.75rem;
    color: #484f58;
  }

  .s-footer a {
    color: #8b949e;
    text-decoration: none;
  }

  .s-footer a:hover {
    color: #c9d1d9;
    text-decoration: underline;
  }

  /* --- Disclaimer/Glossary --- */
  .s-disclaimer {
    margin-top: 32px;
    padding-top: 24px;
    border-top: 1px solid #30363d;
    font-size: 0.8rem;
    color: #8b949e;
    line-height: 1.6;
  }

  .s-disclaimer p {
    margin-bottom: 8px;
  }

  .s-disclaimer strong {
    color: #c9d1d9;
  }

  .s-disclaimer-note {
    font-style: italic;
    margin-top: 12px;
  }

  /* ===========================================
     Responsive
     =========================================== */

  /* Tablet */
  @media (max-width: 1024px) {
    .s-three-col {
      grid-template-columns: 1fr 1fr;
    }

    .s-four-col {
      grid-template-columns: 1fr 1fr;
    }

    .s-hw-row3 {
      grid-template-columns: 1fr;
    }
  }

  /* Mobile */
  @media (max-width: 768px) {
    .s-summary-cards {
      grid-template-columns: repeat(3, 1fr);
    }

    .s-two-col {
      grid-template-columns: 1fr;
    }

    .s-three-col {
      grid-template-columns: 1fr;
    }

    .s-four-col {
      grid-template-columns: 1fr;
    }

    .s-hw-row3 {
      grid-template-columns: 1fr;
    }

    .s-bar-label {
      width: 80px;
      min-width: 80px;
      font-size: 0.75rem;
    }

    .s-bar-label-wide {
      width: 130px;
      min-width: 130px;
    }

    .s-bar-label-narrow {
      width: 60px;
      min-width: 60px;
    }

    .s-card {
      padding: 1rem;
    }

    .s-cm360-label {
      width: 90px;
      min-width: 90px;
    }

    .s-pad-heatmap-grid {
      grid-template-columns: 90px repeat(3, 1fr);
    }

    .s-heatmap-grid .s-hm-data,
    .s-pad-cell {
      min-height: 24px;
      font-size: 0.7rem;
    }

    .s-facts-grid {
      grid-template-columns: 1fr;
    }

    .s-cm360-summary {
      flex-direction: column;
      gap: 0.25rem;
    }

    .s-donut {
      width: 60px;
      height: 60px;
    }

    .s-donut-hole {
      width: 34px;
      height: 34px;
    }

    .s-vbar-chart {
      gap: 12px;
      height: 130px;
    }

    .s-vbar {
      width: 32px;
    }
  }

  @media (max-width: 480px) {
    .s-summary-cards {
      grid-template-columns: repeat(2, 1fr);
    }

    .s-summary-value {
      font-size: 1.35rem;
    }

    .s-bar-label {
      width: 70px;
      min-width: 70px;
    }

    .s-cm360-label {
      width: 75px;
      min-width: 75px;
    }

    .s-cm360-name {
      font-size: 0.65rem;
    }

    .s-pad-heatmap-grid {
      grid-template-columns: 75px repeat(3, 1fr);
    }

    .s-pad-rowlabel-name {
      font-size: 0.6rem;
    }
  }
</style>
