---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';

// Get all hardware
const mice = await getCollection('mice');
const monitors = await getCollection('monitors');
const keyboards = await getCollection('keyboards');
const mousepads = await getCollection('mousepads');
const headsets = await getCollection('headsets');

// Get all players to count hardware usage
const players = await getCollection('players');

// Get players who use each hardware
function getPlayersUsing(hardwareId: string, field: string) {
  return players.filter(p => p.data[field] === hardwareId);
}

// Create usage maps with player data
function createUsageMap(field: string) {
  const map = new Map<string, typeof players>();
  players.forEach(p => {
    const hwId = p.data[field];
    if (hwId) {
      if (!map.has(hwId)) {
        map.set(hwId, []);
      }
      map.get(hwId)!.push(p);
    }
  });
  return map;
}

const mouseUsageMap = createUsageMap('mouse');
const monitorUsageMap = createUsageMap('monitor');
const keyboardUsageMap = createUsageMap('keyboard');
const mousepadUsageMap = createUsageMap('mousepad');
const headsetUsageMap = createUsageMap('headset');

// Sort all hardware by popularity (usage count)
const miceWithUsage = mice.map(m => {
  const usedBy = mouseUsageMap.get(m.id) || [];
  return { ...m, usage: usedBy.length, players: usedBy };
}).sort((a, b) => b.usage - a.usage);

const monitorsWithUsage = monitors.map(m => {
  const usedBy = monitorUsageMap.get(m.id) || [];
  return { ...m, usage: usedBy.length, players: usedBy };
}).sort((a, b) => b.usage - a.usage);

const keyboardsWithUsage = keyboards.map(k => {
  const usedBy = keyboardUsageMap.get(k.id) || [];
  return { ...k, usage: usedBy.length, players: usedBy };
}).sort((a, b) => b.usage - a.usage);

const mousepadsWithUsage = mousepads.map(p => {
  const usedBy = mousepadUsageMap.get(p.id) || [];
  return { ...p, usage: usedBy.length, players: usedBy };
}).sort((a, b) => b.usage - a.usage);

const headsetsWithUsage = headsets.map(h => {
  const usedBy = headsetUsageMap.get(h.id) || [];
  return { ...h, usage: usedBy.length, players: usedBy };
}).sort((a, b) => b.usage - a.usage);

// Count items with players
const miceWithPlayers = miceWithUsage.filter(m => m.usage > 0).length;
const monitorsWithPlayers = monitorsWithUsage.filter(m => m.usage > 0).length;
const keyboardsWithPlayers = keyboardsWithUsage.filter(k => k.usage > 0).length;
const mousepadsWithPlayers = mousepadsWithUsage.filter(p => p.usage > 0).length;
const headsetsWithPlayers = headsetsWithUsage.filter(h => h.usage > 0).length;

// Ensure base URL has trailing slash for path concatenation
const base = import.meta.env.BASE_URL.endsWith('/') ? import.meta.env.BASE_URL : `${import.meta.env.BASE_URL}/`;
---

<BaseLayout title="Hardware Database">
  <div class="page-header">
    <h1>Hardware Database</h1>
    <p>A collection of gaming peripherals and gear used by Quake Live players</p>
  </div>

  <div class="hardware-tabs" role="tablist">
    <button class="tab-btn active" data-tab="mice" role="tab" aria-selected="true">
      Mice <span class="tab-count">({mice.length})</span>
    </button>
    <button class="tab-btn" data-tab="monitors" role="tab" aria-selected="false">
      Monitors <span class="tab-count">({monitors.length})</span>
    </button>
    <button class="tab-btn" data-tab="keyboards" role="tab" aria-selected="false">
      Keyboards <span class="tab-count">({keyboards.length})</span>
    </button>
    <button class="tab-btn" data-tab="mousepads" role="tab" aria-selected="false">
      Mousepads <span class="tab-count">({mousepads.length})</span>
    </button>
    <button class="tab-btn" data-tab="headsets" role="tab" aria-selected="false">
      Headsets <span class="tab-count">({headsets.length})</span>
    </button>
  </div>

  <div class="filters">
    <div class="filter-group">
      <input type="text" id="hardware-search" placeholder="Search by name, brand, or specs..." class="search-input">
    </div>
    <div class="filter-group">
      <label class="toggle-label">
        <input type="checkbox" id="player-used-toggle" checked>
        <span>Show only player-used gear</span>
      </label>
    </div>
  </div>

  <!-- MICE TABLE -->
  <section class="hardware-category active" id="mice" role="tabpanel">
    <div class="table-container">
      <table class="hardware-table" data-type="mice" data-player-count={miceWithPlayers}>
        <thead>
          <tr>
            <th class="sortable" data-sort="name">Name</th>
            <th class="sortable" data-sort="brand">Brand</th>
            <th class="sortable" data-sort="weight">Weight</th>
            <th class="sortable" data-sort="shape">Shape</th>
            <th class="sortable" data-sort="sensor">Sensor</th>
            <th class="sortable" data-sort="connection">Connection</th>
            <th class="sortable num sort-desc" data-sort="usage">Players</th>
          </tr>
        </thead>
        <tbody>
          {miceWithUsage.map((mouse) => (
            <tr
              data-name={mouse.data.name.toLowerCase()}
              data-brand={mouse.data.brand.toLowerCase()}
              data-weight={mouse.data.weight}
              data-shape={mouse.data.shape?.toLowerCase() || ''}
              data-sensor={mouse.data.sensor?.toLowerCase() || ''}
              data-connection={mouse.data.connection?.toLowerCase() || ''}
              data-usage={mouse.usage}
            >
              <td class="name-cell">
                {mouse.data.name}
              </td>
              <td>{mouse.data.brand}</td>
              <td class="spec-cell">{mouse.data.weight}</td>
              <td class="spec-cell">{mouse.data.shape}</td>
              <td class="spec-cell">{mouse.data.sensor}</td>
              <td class="spec-cell">{mouse.data.connection}</td>
              <td class="num usage-cell">
                {mouse.usage > 0 ? (
                  <div class="usage-wrapper">
                    <span class="usage-count">{mouse.usage}</span>
                    <div class="player-dropdown">
                      {mouse.players.map(p => (
                        <a href={`${base}players/${p.id}/`}>{p.data.name}</a>
                      ))}
                    </div>
                  </div>
                ) : '—'}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <!-- MONITORS TABLE -->
  <section class="hardware-category" id="monitors" role="tabpanel">
    <div class="table-container">
      <table class="hardware-table" data-type="monitors" data-player-count={monitorsWithPlayers}>
        <thead>
          <tr>
            <th class="sortable" data-sort="name">Name</th>
            <th class="sortable" data-sort="brand">Brand</th>
            <th class="sortable" data-sort="size">Size</th>
            <th class="sortable" data-sort="refresh">Refresh Rate</th>
            <th class="sortable" data-sort="panel">Panel</th>
            <th class="sortable" data-sort="resolution">Resolution</th>
            <th class="sortable num sort-desc" data-sort="usage">Players</th>
          </tr>
        </thead>
        <tbody>
          {monitorsWithUsage.map((monitor) => (
            <tr
              data-name={monitor.data.name.toLowerCase()}
              data-brand={monitor.data.brand.toLowerCase()}
              data-size={monitor.data.size}
              data-refresh={monitor.data.refreshRate}
              data-panel={(monitor.data.panelType || monitor.data.panel || '').toLowerCase()}
              data-resolution={monitor.data.resolution}
              data-usage={monitor.usage}
            >
              <td class="name-cell">
                {monitor.data.name}
              </td>
              <td>{monitor.data.brand}</td>
              <td class="spec-cell">{monitor.data.size}</td>
              <td class="spec-cell">{monitor.data.refreshRate}</td>
              <td class="spec-cell">{monitor.data.panelType || monitor.data.panel}</td>
              <td class="spec-cell">{monitor.data.resolution}</td>
              <td class="num usage-cell">
                {monitor.usage > 0 ? (
                  <div class="usage-wrapper">
                    <span class="usage-count">{monitor.usage}</span>
                    <div class="player-dropdown">
                      {monitor.players.map(p => (
                        <a href={`${base}players/${p.id}/`}>{p.data.name}</a>
                      ))}
                    </div>
                  </div>
                ) : '—'}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <!-- KEYBOARDS TABLE -->
  <section class="hardware-category" id="keyboards" role="tabpanel">
    <div class="table-container">
      <table class="hardware-table" data-type="keyboards" data-player-count={keyboardsWithPlayers}>
        <thead>
          <tr>
            <th class="sortable" data-sort="name">Name</th>
            <th class="sortable" data-sort="brand">Brand</th>
            <th class="sortable" data-sort="size">Size</th>
            <th class="sortable" data-sort="switches">Switches</th>
            <th class="sortable" data-sort="connection">Connection</th>
            <th class="sortable num sort-desc" data-sort="usage">Players</th>
          </tr>
        </thead>
        <tbody>
          {keyboardsWithUsage.map((kb) => (
            <tr
              data-name={kb.data.name.toLowerCase()}
              data-brand={kb.data.brand.toLowerCase()}
              data-size={(kb.data.size || kb.data.format || '').toLowerCase()}
              data-switches={(kb.data.switches || '').toLowerCase()}
              data-connection={(kb.data.connection || '').toLowerCase()}
              data-usage={kb.usage}
            >
              <td class="name-cell">
                {kb.data.name}
              </td>
              <td>{kb.data.brand}</td>
              <td class="spec-cell">{kb.data.size || kb.data.format}</td>
              <td class="spec-cell">{kb.data.switches}</td>
              <td class="spec-cell">{kb.data.connection}</td>
              <td class="num usage-cell">
                {kb.usage > 0 ? (
                  <div class="usage-wrapper">
                    <span class="usage-count">{kb.usage}</span>
                    <div class="player-dropdown">
                      {kb.players.map(p => (
                        <a href={`${base}players/${p.id}/`}>{p.data.name}</a>
                      ))}
                    </div>
                  </div>
                ) : '—'}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <!-- MOUSEPADS TABLE -->
  <section class="hardware-category" id="mousepads" role="tabpanel">
    <div class="table-container">
      <table class="hardware-table" data-type="mousepads" data-player-count={mousepadsWithPlayers}>
        <thead>
          <tr>
            <th class="sortable" data-sort="name">Name</th>
            <th class="sortable" data-sort="brand">Brand</th>
            <th class="sortable" data-sort="surface">Surface</th>
            <th class="sortable" data-sort="speed">Speed</th>
            <th class="sortable" data-sort="dimensions">Dimensions</th>
            <th class="sortable num sort-desc" data-sort="usage">Players</th>
          </tr>
        </thead>
        <tbody>
          {mousepadsWithUsage.map((pad) => (
            <tr
              data-name={pad.data.name.toLowerCase()}
              data-brand={pad.data.brand.toLowerCase()}
              data-surface={(pad.data.surface || '').toLowerCase()}
              data-speed={(pad.data.speed || pad.data.speedType || '').toLowerCase()}
              data-dimensions={(pad.data.dimensions || pad.data.size || '')}
              data-usage={pad.usage}
            >
              <td class="name-cell">
                {pad.data.name}
              </td>
              <td>{pad.data.brand}</td>
              <td class="spec-cell">{pad.data.surface}</td>
              <td class="spec-cell">{pad.data.speed || pad.data.speedType}</td>
              <td class="spec-cell">{pad.data.dimensions || pad.data.size}</td>
              <td class="num usage-cell">
                {pad.usage > 0 ? (
                  <div class="usage-wrapper">
                    <span class="usage-count">{pad.usage}</span>
                    <div class="player-dropdown">
                      {pad.players.map(p => (
                        <a href={`${base}players/${p.id}/`}>{p.data.name}</a>
                      ))}
                    </div>
                  </div>
                ) : '—'}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <!-- HEADSETS TABLE -->
  <section class="hardware-category" id="headsets" role="tabpanel">
    <div class="table-container">
      <table class="hardware-table" data-type="headsets" data-player-count={headsetsWithPlayers}>
        <thead>
          <tr>
            <th class="sortable" data-sort="name">Name</th>
            <th class="sortable" data-sort="brand">Brand</th>
            <th class="sortable" data-sort="type">Type</th>
            <th class="sortable" data-sort="driver">Driver</th>
            <th class="sortable" data-sort="connection">Connection</th>
            <th class="sortable" data-sort="microphone">Mic</th>
            <th class="sortable num sort-desc" data-sort="usage">Players</th>
          </tr>
        </thead>
        <tbody>
          {headsetsWithUsage.map((hs) => (
            <tr
              data-name={hs.data.name.toLowerCase()}
              data-brand={hs.data.brand.toLowerCase()}
              data-type={(hs.data.type || '').toLowerCase()}
              data-driver={(hs.data.driverSize || hs.data.driver || '')}
              data-connection={(hs.data.connection || '').toLowerCase()}
              data-microphone={hs.data.microphone ? 'yes' : 'no'}
              data-usage={hs.usage}
            >
              <td class="name-cell">
                {hs.data.name}
              </td>
              <td>{hs.data.brand}</td>
              <td class="spec-cell">{hs.data.type}</td>
              <td class="spec-cell">{hs.data.driverSize || hs.data.driver}</td>
              <td class="spec-cell">{hs.data.connection}</td>
              <td class="center">{hs.data.microphone ? '✓' : '—'}</td>
              <td class="num usage-cell">
                {hs.usage > 0 ? (
                  <div class="usage-wrapper">
                    <span class="usage-count">{hs.usage}</span>
                    <div class="player-dropdown">
                      {hs.players.map(p => (
                        <a href={`${base}players/${p.id}/`}>{p.data.name}</a>
                      ))}
                    </div>
                  </div>
                ) : '—'}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

</BaseLayout>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('hardware-search') as HTMLInputElement;
    const playerUsedToggle = document.getElementById('player-used-toggle') as HTMLInputElement;
    const tabButtons = document.querySelectorAll('.tab-btn');
    const categories = document.querySelectorAll('.hardware-category');
    const tables = document.querySelectorAll('.hardware-table');

    // Track sort state per table
    const sortState: Record<string, { col: string; asc: boolean }> = {};

    // Initialize sort state - default to usage descending
    tables.forEach(table => {
      const tableType = table.getAttribute('data-type') || '';
      sortState[tableType] = { col: 'usage', asc: false };
    });

    function switchTab(tabId: string) {
      // Update tab buttons
      tabButtons.forEach(btn => {
        const isActive = btn.getAttribute('data-tab') === tabId;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-selected', isActive.toString());
      });

      // Update category visibility
      categories.forEach(cat => {
        cat.classList.toggle('active', cat.id === tabId);
      });

      // Update URL hash without scrolling
      history.replaceState(null, '', `#${tabId}`);

      // Re-apply filters
      filterCurrentTable();
    }

    function filterCurrentTable() {
      const activeCategory = document.querySelector('.hardware-category.active');
      if (!activeCategory) return;

      const table = activeCategory.querySelector('.hardware-table');
      if (!table) return;

      const search = searchInput?.value.toLowerCase() || '';
      const playerUsedOnly = playerUsedToggle?.checked ?? true;

      const tbody = table.querySelector('tbody');
      const rows = tbody?.querySelectorAll('tr') || [];
      let visibleCount = 0;

      rows.forEach(row => {
        const name = row.getAttribute('data-name') || '';
        const brand = row.getAttribute('data-brand') || '';
        const sensor = row.getAttribute('data-sensor') || '';
        const shape = row.getAttribute('data-shape') || '';
        const connection = row.getAttribute('data-connection') || '';
        const usage = parseInt(row.getAttribute('data-usage') || '0');

        // Search filter - check all data attributes
        const matchesSearch = !search ||
          name.includes(search) ||
          brand.includes(search) ||
          sensor.includes(search) ||
          shape.includes(search) ||
          connection.includes(search);

        // Player-used filter
        const matchesPlayerFilter = !playerUsedOnly || usage > 0;

        const show = matchesSearch && matchesPlayerFilter;
        (row as HTMLElement).style.display = show ? '' : 'none';
        if (show) visibleCount++;
      });

      // Update visible count in tab
      const tableType = table.getAttribute('data-type');
      const tabBtn = document.querySelector(`.tab-btn[data-tab="${tableType}"]`);
      const countSpan = tabBtn?.querySelector('.tab-count');
      if (countSpan) {
        const totalCount = rows.length;
        if (playerUsedOnly || search) {
          countSpan.textContent = `(${visibleCount}/${totalCount})`;
        } else {
          countSpan.textContent = `(${totalCount})`;
        }
      }
    }

    function sortTable(table: Element, col: string, asc: boolean) {
      const tbody = table.querySelector('tbody');
      if (!tbody) return;

      const rows = Array.from(tbody.querySelectorAll('tr'));

      rows.sort((a, b) => {
        let aVal: string | number = a.getAttribute(`data-${col}`) || '';
        let bVal: string | number = b.getAttribute(`data-${col}`) || '';

        // Handle numeric columns
        if (col === 'usage') {
          aVal = parseInt(aVal as string) || 0;
          bVal = parseInt(bVal as string) || 0;
          return asc ? (aVal as number) - (bVal as number) : (bVal as number) - (aVal as number);
        }

        // Handle weight (extract numeric value)
        if (col === 'weight') {
          const aNum = parseFloat((aVal as string).replace(/[^\d.]/g, '')) || 0;
          const bNum = parseFloat((bVal as string).replace(/[^\d.]/g, '')) || 0;
          return asc ? aNum - bNum : bNum - aNum;
        }

        // String comparison
        return asc
          ? (aVal as string).localeCompare(bVal as string)
          : (bVal as string).localeCompare(aVal as string);
      });

      rows.forEach(row => tbody.appendChild(row));
    }

    // Tab click handlers
    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const tabId = btn.getAttribute('data-tab');
        if (tabId) switchTab(tabId);
      });
    });

    // Search input handler
    searchInput?.addEventListener('input', filterCurrentTable);

    // Player-used toggle handler
    playerUsedToggle?.addEventListener('change', filterCurrentTable);

    // Sort handlers for each table
    tables.forEach(table => {
      const tableType = table.getAttribute('data-type') || '';

      const headers = table.querySelectorAll('th.sortable');
      headers.forEach(header => {
        header.addEventListener('click', () => {
          const col = header.getAttribute('data-sort') || '';
          const state = sortState[tableType];

          if (state.col === col) {
            state.asc = !state.asc;
          } else {
            state.col = col;
            state.asc = true;
          }

          // Update header styles
          headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
          header.classList.add(state.asc ? 'sort-asc' : 'sort-desc');

          sortTable(table, col, state.asc);
        });
      });
    });

    // Handle initial hash or default to mice
    function handleHash() {
      const hash = window.location.hash.replace('#', '') || 'mice';
      const validTabs = ['mice', 'monitors', 'keyboards', 'mousepads', 'headsets'];
      const tabId = validTabs.includes(hash) ? hash : 'mice';
      switchTab(tabId);
    }

    // Listen for hash changes
    window.addEventListener('hashchange', handleHash);

    // Initial load
    handleHash();
  });
</script>

<style>
  .hardware-tabs {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    margin-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-color, #2a2a3a);
    padding-bottom: 0;
  }

  .tab-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.75rem 1.25rem;
    background: transparent;
    border: none;
    border-bottom: 2px solid transparent;
    color: var(--text-secondary, #888);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    margin-bottom: -1px;
  }

  .tab-btn:hover {
    color: var(--text-primary, #fff);
    background: rgba(255, 255, 255, 0.05);
  }

  .tab-btn.active {
    color: var(--accent-primary, #ff6b35);
    border-bottom-color: var(--accent-primary, #ff6b35);
  }

  .tab-count {
    font-size: 0.8em;
    opacity: 0.7;
  }

  .filters {
    display: flex;
    gap: 1.5rem;
    flex-wrap: wrap;
    align-items: center;
    margin-bottom: 1.5rem;
  }

  .filter-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .search-input {
    background: var(--bg-secondary, #12121a);
    border: 1px solid var(--border-color, #2a2a3a);
    color: var(--text-primary, #fff);
    padding: 0.5rem 0.75rem;
    border-radius: 4px;
    min-width: 280px;
  }

  .toggle-label {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-size: 0.875rem;
    color: var(--text-secondary, #888);
    user-select: none;
  }

  .toggle-label:hover {
    color: var(--text-primary, #fff);
  }

  .toggle-label input[type="checkbox"] {
    width: 1rem;
    height: 1rem;
    accent-color: var(--accent-primary, #ff6b35);
    cursor: pointer;
  }

  .hardware-category {
    display: none;
  }

  .hardware-category.active {
    display: block;
  }

  .table-container {
    overflow-x: auto;
  }

  .hardware-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
  }

  .hardware-table th,
  .hardware-table td {
    padding: 0.6rem 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--border-color, #2a2a3a);
  }

  .hardware-table th {
    background: var(--bg-secondary, #12121a);
    font-weight: 600;
    color: var(--text-secondary, #888);
    text-transform: uppercase;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    white-space: nowrap;
    position: sticky;
    top: 0;
  }

  .hardware-table th.sortable {
    cursor: pointer;
    user-select: none;
  }

  .hardware-table th.sortable:hover {
    color: var(--accent-primary, #ff6b35);
  }

  .hardware-table th.sortable::after {
    content: ' ↕';
    opacity: 0.3;
  }

  .hardware-table th.sort-asc::after {
    content: ' ↑';
    opacity: 1;
  }

  .hardware-table th.sort-desc::after {
    content: ' ↓';
    opacity: 1;
  }

  /* Zebra striping */
  .hardware-table tbody tr:nth-child(odd) {
    background: rgba(255, 255, 255, 0.02);
  }

  .hardware-table tbody tr:nth-child(even) {
    background: transparent;
  }

  .hardware-table tbody tr:hover {
    background: var(--bg-secondary, #12121a);
  }

  .name-cell {
    font-weight: 500;
    white-space: nowrap;
  }

  .spec-cell {
    color: var(--text-secondary, #ccc);
    font-size: 0.8rem;
  }

  .num {
    text-align: right;
    font-family: monospace;
  }

  .center {
    text-align: center;
  }

  .usage-cell {
    color: var(--accent-primary, #ff6b35);
    font-weight: 500;
    position: relative;
  }

  .usage-wrapper {
    position: relative;
    display: inline-block;
    cursor: pointer;
  }

  .usage-count {
    text-decoration: underline;
    text-decoration-style: dotted;
    text-underline-offset: 2px;
  }

  .usage-wrapper:hover .usage-count {
    color: var(--accent-secondary, #4ecdc4);
  }

  .player-dropdown {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    z-index: 100;
    background: var(--bg-card, #1a1a24);
    border: 1px solid var(--border-color, #2a2a3a);
    border-radius: 6px;
    padding: 0.5rem 0;
    min-width: 150px;
    max-width: 200px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
  }

  .usage-wrapper:hover .player-dropdown {
    display: block;
  }

  .player-dropdown a {
    display: block;
    padding: 0.4rem 0.75rem;
    color: var(--text-primary, #fff);
    text-decoration: none;
    font-size: 0.8rem;
    font-family: inherit;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .player-dropdown a:hover {
    background: var(--bg-secondary, #12121a);
    color: var(--accent-primary, #ff6b35);
  }

  @media (max-width: 1024px) {
    .hardware-table {
      font-size: 0.75rem;
    }

    .hardware-table th,
    .hardware-table td {
      padding: 0.4rem 0.5rem;
    }

    .search-input {
      min-width: 200px;
    }

    .filters {
      gap: 1rem;
    }
  }

  @media (max-width: 640px) {
    .tab-btn {
      font-size: 0.8rem;
      padding: 0.5rem 0.75rem;
    }

    .filters {
      flex-direction: column;
      align-items: stretch;
    }

    .search-input {
      min-width: 100%;
    }
  }
</style>
